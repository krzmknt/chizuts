<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>graphts - Dependency Graph Visualizer</title>
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #1a1a2e;
        color: #eee;
        overflow: hidden;
      }

      #header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 50px;
        background: #16213e;
        display: flex;
        align-items: center;
        padding: 0 20px;
        gap: 20px;
        z-index: 100;
        border-bottom: 1px solid #0f3460;
      }

      #header h1 {
        font-size: 18px;
        font-weight: 600;
        color: #22d3ee;
      }

      #stats {
        font-size: 14px;
        color: #888;
      }

      #controls {
        display: flex;
        gap: 10px;
        margin-left: auto;
      }

      button {
        background: #0f3460;
        color: #eee;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        transition: background 0.2s;
      }

      button:hover {
        background: #22d3ee;
        color: #1a1a2e;
      }

      select {
        background: #0f3460;
        color: #eee;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 13px;
      }

      #left-sidebar {
        position: fixed;
        top: 50px;
        left: 0;
        width: 280px;
        bottom: 0;
        background: #16213e;
        border-right: 1px solid #0f3460;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        transition:
          width 0.3s,
          transform 0.3s;
      }

      #left-sidebar.collapsed {
        width: 0;
        transform: translateX(-280px);
      }

      .sidebar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 6px 15px;
        margin-bottom: 10px;
        border-bottom: 1px solid #0f3460;
        background: #16213e;
      }

      .sidebar-header h3 {
        margin: 0;
        font-size: 12px;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .close-btn {
        width: 20px;
        height: 20px;
        background: transparent;
        border: none;
        color: #888;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        padding: 0;
        border-radius: 2px;
      }

      .close-btn:hover {
        color: #22d3ee;
        background: rgba(34, 211, 238, 0.1);
      }

      .expand-tab {
        position: fixed;
        top: 58px;
        padding: 6px 8px;
        background: #16213e;
        border: 1px solid #0f3460;
        color: #888;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 101;
      }

      .expand-tab:hover {
        color: #22d3ee;
        background: #0f3460;
      }

      #left-expand {
        left: 0;
        border-left: none;
        border-radius: 0 4px 4px 0;
      }

      #right-expand {
        right: 0;
        border-right: none;
        border-radius: 4px 0 0 4px;
      }

      body.left-collapsed #left-expand {
        display: flex;
      }

      body.right-collapsed #right-expand {
        display: flex;
      }

      #search-container {
        padding: 15px;
        border-bottom: 1px solid #0f3460;
      }

      #search-input {
        width: 100%;
        background: #0f3460;
        color: #eee;
        border: 1px solid #1a1a2e;
        padding: 10px 12px;
        border-radius: 4px;
        font-size: 13px;
        outline: none;
        transition: border-color 0.2s;
      }

      #search-input:focus {
        border-color: #22d3ee;
      }

      #search-input::placeholder {
        color: #666;
      }

      #search-results {
        font-size: 12px;
        color: #888;
        margin-top: 8px;
      }

      #file-tree-container {
        flex: 1;
        overflow-y: auto;
        padding: 10px 0;
      }

      .tree-item {
        padding: 6px 15px 6px 15px;
        font-size: 13px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: background 0.15s;
      }

      .tree-item:hover {
        background: #0f3460;
      }

      .tree-item.selected {
        background: #0891b2;
      }

      .tree-item.match {
        background: rgba(34, 211, 238, 0.3);
      }

      .tree-folder {
        color: #888;
        font-weight: 500;
      }

      .tree-folder::before {
        content: 'ðŸ“';
        font-size: 12px;
      }

      .tree-folder.open::before {
        content: 'ðŸ“‚';
      }

      .tree-file::before {
        content: 'ðŸ“„';
        font-size: 12px;
      }

      .tree-symbol {
        color: #ccc;
      }

      .symbol-icon {
        display: inline-block;
        width: 16px;
        height: 16px;
        line-height: 16px;
        text-align: center;
        border-radius: 3px;
        font-size: 10px;
        font-weight: bold;
        margin-right: 4px;
      }

      .tree-symbol-function .symbol-icon {
        background: #2ecc71;
        color: #fff;
      }

      .tree-symbol-class .symbol-icon {
        background: #9b59b6;
        color: #fff;
      }

      .tree-symbol-variable .symbol-icon {
        background: #f39c12;
        color: #fff;
      }

      .tree-symbol-component .symbol-icon {
        background: #e74c3c;
        color: #fff;
      }

      .tree-symbol-interface .symbol-icon {
        background: #1abc9c;
        color: #fff;
      }

      .tree-symbol-type .symbol-icon {
        background: #e67e22;
        color: #fff;
      }

      .tree-symbol-enum .symbol-icon {
        background: #8e44ad;
        color: #fff;
      }

      .tree-symbol-method .symbol-icon {
        background: #27ae60;
        color: #fff;
      }

      .tree-symbol-field .symbol-icon {
        background: #d35400;
        color: #fff;
      }

      .tree-children {
        display: none;
      }

      .tree-children.open {
        display: block;
      }

      /* Dynamic indentation - base padding + depth * 15px */

      #cy {
        position: fixed;
        top: 50px;
        left: 280px;
        right: 300px;
        bottom: 0;
        transition:
          left 0.3s,
          right 0.3s;
      }

      body.left-collapsed #cy {
        left: 0;
      }

      body.right-collapsed #cy {
        right: 0;
      }

      #sidebar {
        position: fixed;
        top: 50px;
        right: 0;
        width: 300px;
        bottom: 0;
        background: #16213e;
        border-left: 1px solid #0f3460;
        overflow-y: auto;
        transition:
          width 0.3s,
          transform 0.3s;
      }

      #sidebar.collapsed {
        width: 0;
        transform: translateX(300px);
        overflow: hidden;
      }

      #sidebar > h2,
      #sidebar > #node-info,
      #sidebar > #legend,
      #sidebar > #edge-legend,
      #sidebar > #orphan-filter,
      #sidebar > #pattern-filter {
        padding-left: 20px;
        padding-right: 20px;
      }

      #sidebar h2 {
        font-size: 14px;
        color: #888;
        margin-top: 15px;
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      #node-info {
        font-size: 13px;
        line-height: 1.6;
      }

      #node-info .label {
        color: #22d3ee;
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 10px;
      }

      #node-info .type {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 3px;
        font-size: 11px;
        text-transform: uppercase;
        margin-bottom: 15px;
      }

      /* TYPE badge colors are set dynamically from NODE_COLORS in JavaScript */

      #node-info .path {
        color: #888;
        font-family: monospace;
        font-size: 12px;
        word-break: break-all;
      }

      #node-info .location {
        color: #666;
        font-size: 12px;
        margin-top: 5px;
      }

      #filter-section {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #0f3460;
      }

      #filter-section label {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 8px 0;
        cursor: pointer;
        font-size: 13px;
      }

      #filter-section input[type='checkbox'] {
        width: 16px;
        height: 16px;
      }

      #legend {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #0f3460;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 6px 0;
        font-size: 12px;
      }

      .legend-item.clickable {
        cursor: pointer;
        padding: 4px 8px;
        margin: 4px -8px;
        border-radius: 4px;
        transition:
          background 0.15s,
          opacity 0.15s;
      }

      .legend-item.clickable:hover {
        background: #0f3460;
      }

      .legend-item.clickable.inactive {
        opacity: 0.4;
      }

      .legend-item.clickable.inactive .legend-color,
      .legend-item.clickable.inactive .legend-line {
        background: #555 !important;
      }

      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 2px;
      }

      .legend-line {
        width: 20px;
        height: 3px;
        border-radius: 1px;
      }

      #edge-legend {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #0f3460;
      }

      #pattern-filter {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #0f3460;
      }

      #pattern-filter h2 {
        font-size: 14px;
        color: #888;
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      #loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 18px;
        color: #888;
      }
    </style>
  </head>
  <body>
    <div id="header">
      <h1>graphts</h1>
      <span id="stats">Loading...</span>
      <div id="controls">
        <select id="layout">
          <option value="dagre">Hierarchical (TB)</option>
          <option value="dagre-lr">Hierarchical (LR)</option>
          <option value="dagre-compact">Hierarchical (Compact)</option>
          <option value="cose">Force-directed</option>
          <option value="breadthfirst">Breadthfirst</option>
          <option value="concentric">Concentric</option>
          <option value="circle">Circle</option>
          <option value="grid">Grid</option>
        </select>
        <button id="fit-btn">Fit to Screen</button>
        <button id="export-btn">Export PNG</button>
      </div>
    </div>

    <button id="left-expand" class="expand-tab" title="Show file tree">
      FILES
    </button>
    <button id="right-expand" class="expand-tab" title="Show details">
      DETAILS
    </button>

    <div id="left-sidebar">
      <div class="sidebar-header">
        <h3>Files</h3>
        <button id="left-close" class="close-btn" title="Hide file tree">
          &times;
        </button>
      </div>
      <div id="search-container">
        <input
          type="text"
          id="search-input"
          placeholder="Search files..."
          autocomplete="off"
        />
        <div id="search-results"></div>
      </div>
      <div id="file-tree-container">
        <div id="file-tree"></div>
      </div>
    </div>

    <div id="cy"></div>

    <div id="sidebar">
      <div class="sidebar-header">
        <h3>Details</h3>
        <button id="right-close" class="close-btn" title="Hide details">
          &times;
        </button>
      </div>
      <h2>Node Details</h2>
      <div id="node-info">
        <p style="color: #666">Click a node to see details</p>
      </div>

      <div id="legend">
        <h2>Nodes</h2>
        <div class="legend-item clickable" data-type="module">
          <div class="legend-color" style="background: #3498db"></div>
          Module
        </div>
        <div class="legend-item clickable" data-type="function">
          <div class="legend-color" style="background: #2ecc71"></div>
          Function
        </div>
        <div class="legend-item clickable" data-type="class">
          <div class="legend-color" style="background: #9b59b6"></div>
          Class
        </div>
        <div class="legend-item clickable" data-type="variable">
          <div class="legend-color" style="background: #f39c12"></div>
          Variable
        </div>
        <div class="legend-item clickable" data-type="component">
          <div class="legend-color" style="background: #e74c3c"></div>
          Component
        </div>
        <div class="legend-item clickable" data-type="interface">
          <div class="legend-color" style="background: #1abc9c"></div>
          Interface
        </div>
        <div class="legend-item clickable" data-type="type">
          <div class="legend-color" style="background: #e67e22"></div>
          Type
        </div>
        <div class="legend-item clickable" data-type="enum">
          <div class="legend-color" style="background: #8e44ad"></div>
          Enum
        </div>
        <div class="legend-item clickable" data-type="method">
          <div class="legend-color" style="background: #27ae60"></div>
          Method
        </div>
        <div class="legend-item clickable" data-type="field">
          <div class="legend-color" style="background: #d35400"></div>
          Field
        </div>
      </div>

      <div id="edge-legend">
        <h2>Edges</h2>
        <div class="legend-item clickable" data-edge-type="import">
          <div class="legend-line" style="background: #3498db"></div>
          import
        </div>
        <div class="legend-item clickable" data-edge-type="defines">
          <div class="legend-line" style="background: #7f8c8d"></div>
          defines
        </div>
        <div class="legend-item clickable" data-edge-type="call">
          <div class="legend-line" style="background: #e74c3c"></div>
          call
        </div>
        <div class="legend-item clickable" data-edge-type="reference">
          <div class="legend-line" style="background: #f39c12"></div>
          reference
        </div>
        <div class="legend-item clickable" data-edge-type="extends">
          <div class="legend-line" style="background: #9b59b6"></div>
          extends
        </div>
        <div class="legend-item clickable" data-edge-type="implements">
          <div class="legend-line" style="background: #e91e63"></div>
          implements
        </div>
      </div>

      <div
        id="orphan-filter"
        style="
          margin-top: 20px;
          padding-top: 20px;
          border-top: 1px solid #0f3460;
        "
      >
        <h2>Display Options</h2>
        <label
          style="
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
            cursor: pointer;
            font-size: 13px;
          "
        >
          <input
            type="checkbox"
            id="hide-orphans"
            style="width: 16px; height: 16px"
          />
          Hide orphan nodes (no connections)
        </label>
        <div
          id="orphan-stats"
          style="font-size: 11px; color: #888; margin-top: 4px"
        ></div>
      </div>

      <div id="pattern-filter">
        <h2>Pattern Filter</h2>
        <div style="margin-bottom: 10px">
          <label
            style="
              font-size: 12px;
              color: #888;
              display: block;
              margin-bottom: 4px;
            "
            >Exclude patterns (one per line)</label
          >
          <textarea
            id="exclude-patterns"
            placeholder="*test*&#10;*.spec.*&#10;__mocks__/*"
            rows="3"
            style="
              width: 100%;
              background: #0f3460;
              color: #eee;
              border: 1px solid #1a1a2e;
              border-radius: 4px;
              padding: 8px;
              font-size: 12px;
              font-family: monospace;
              resize: vertical;
            "
          ></textarea>
        </div>
        <div style="margin-bottom: 10px">
          <label
            style="
              font-size: 12px;
              color: #888;
              display: block;
              margin-bottom: 4px;
            "
            >Include patterns (empty = all)</label
          >
          <textarea
            id="include-patterns"
            placeholder="src/*&#10;*.ts"
            rows="2"
            style="
              width: 100%;
              background: #0f3460;
              color: #eee;
              border: 1px solid #1a1a2e;
              border-radius: 4px;
              padding: 8px;
              font-size: 12px;
              font-family: monospace;
              resize: vertical;
            "
          ></textarea>
        </div>
        <button id="apply-pattern-filter" style="width: 100%">
          Apply Filter
        </button>
        <div
          id="filter-stats"
          style="font-size: 11px; color: #888; margin-top: 8px"
        ></div>
      </div>
    </div>

    <div id="loading">Loading graph...</div>

    <script>
      const NODE_COLORS = {
        module: '#3498db',
        function: '#2ecc71',
        class: '#9b59b6',
        variable: '#f39c12',
        component: '#e74c3c',
        interface: '#1abc9c',
        type: '#e67e22',
        enum: '#8e44ad',
        method: '#27ae60',
        field: '#d35400',
      };

      const EDGE_COLORS = {
        import: '#3498db',
        export: '#7f8c8d', // "defines" - module contains this symbol
        call: '#e74c3c',
        reference: '#f39c12',
        extends: '#9b59b6',
        implements: '#e91e63', // pink - distinct from green
      };

      let cy;
      let graphNodes = [];

      // Build directory tree from relative file paths with child symbols
      function buildFileTree(nodes) {
        const tree = {};

        // Get modules and their children
        const modules = nodes.filter((n) => n.type === 'module');
        const topLevelSymbols = nodes.filter(
          (n) =>
            n.type !== 'module' && n.type !== 'method' && n.type !== 'field'
        );
        const memberSymbols = nodes.filter(
          (n) => n.type === 'method' || n.type === 'field'
        );

        // Build module tree
        for (const node of modules) {
          const parts = node.label.split('/').filter(Boolean);
          let current = tree;

          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            const isFile = i === parts.length - 1;

            if (!current[part]) {
              current[part] = isFile
                ? {
                    __isFile: true,
                    __nodeId: node.id,
                    __label: node.label,
                    __children: [],
                  }
                : {};
            }
            current = current[part];
          }
        }

        // Add top-level symbols to their parent modules
        for (const symbol of topLevelSymbols) {
          // Find parent module by matching file path
          const parentModule = modules.find((m) =>
            symbol.id.startsWith(m.id + '#')
          );
          if (parentModule) {
            const parts = parentModule.label.split('/').filter(Boolean);
            let current = tree;

            for (const part of parts) {
              if (current[part]) {
                current = current[part];
              }
            }

            if (current.__children) {
              current.__children.push({
                id: symbol.id,
                label: symbol.label,
                type: symbol.type,
                __members: [], // For classes to hold methods/fields
              });
            }
          }
        }

        // Add methods/fields to their parent class
        for (const member of memberSymbols) {
          // Member ID format: module#ClassName.memberName
          // Find parent class by checking if class ID is prefix of member ID
          const parentClass = topLevelSymbols.find(
            (s) => s.type === 'class' && member.id.startsWith(s.id + '.')
          );
          if (parentClass) {
            // Find the class in the tree and add the member
            const parentModule = modules.find((m) =>
              parentClass.id.startsWith(m.id + '#')
            );
            if (parentModule) {
              const parts = parentModule.label.split('/').filter(Boolean);
              let current = tree;

              for (const part of parts) {
                if (current[part]) {
                  current = current[part];
                }
              }

              if (current.__children) {
                const classEntry = current.__children.find(
                  (c) => c.id === parentClass.id
                );
                if (classEntry && classEntry.__members) {
                  classEntry.__members.push({
                    id: member.id,
                    label: member.label,
                    type: member.type,
                  });
                }
              }
            }
          }
        }

        return tree;
      }

      // Convert glob pattern to regex
      function globToRegex(glob) {
        // Escape special regex characters except * and ?
        let regex = glob
          .replace(/[.+^${}()|[\]\\]/g, '\\$&')
          // Convert ** to match anything including /
          .replace(/\*\*/g, '.*')
          // Convert * to match anything except /
          .replace(/\*/g, '[^/]*')
          // Convert ? to match single character
          .replace(/\?/g, '.');
        return new RegExp(regex, 'i');
      }

      // Check if a path matches any of the patterns
      function matchesPatterns(path, patterns) {
        if (!patterns || patterns.length === 0) return false;
        return patterns.some((pattern) => {
          try {
            const regex = globToRegex(pattern);
            return regex.test(path);
          } catch (e) {
            return false;
          }
        });
      }

      // Symbol type icons
      const SYMBOL_ICONS = {
        module: 'M',
        function: 'Æ’',
        class: 'C',
        variable: 'V',
        component: 'âš›',
        interface: 'I',
        type: 'T',
        enum: 'E',
        method: 'm',
        field: 'f',
      };

      // Render the file tree
      function renderFileTree(tree, container, depth = 0) {
        const entries = Object.entries(tree).sort(([a, aVal], [b, bVal]) => {
          // Folders first, then files
          const aIsFile = aVal.__isFile;
          const bIsFile = bVal.__isFile;
          if (aIsFile !== bIsFile) return aIsFile ? 1 : -1;
          return a.localeCompare(b);
        });

        for (const [name, value] of entries) {
          if (name.startsWith('__')) continue;

          const isFile = value.__isFile;
          const indentPadding = 15 + depth * 15; // Base 15px + 15px per depth level

          if (isFile) {
            const fileItem = document.createElement('div');
            fileItem.className = 'tree-item tree-file';
            fileItem.style.paddingLeft = `${indentPadding}px`;
            fileItem.textContent = name;
            fileItem.dataset.nodeId = value.__nodeId;

            const fileChildren = document.createElement('div');
            fileChildren.className = 'tree-children';

            // Render symbol children
            if (value.__children && value.__children.length > 0) {
              const sortedSymbols = value.__children.sort((a, b) =>
                a.label.localeCompare(b.label)
              );

              for (const symbol of sortedSymbols) {
                const symbolItem = document.createElement('div');
                symbolItem.className = `tree-item tree-symbol tree-symbol-${symbol.type}`;
                symbolItem.style.paddingLeft = `${indentPadding + 15}px`;
                symbolItem.dataset.nodeId = symbol.id;
                symbolItem.innerHTML = `<span class="symbol-icon">${SYMBOL_ICONS[symbol.type] || 'â€¢'}</span> ${symbol.label}`;

                // If symbol has members (class with methods/fields), make it expandable
                if (symbol.__members && symbol.__members.length > 0) {
                  const memberContainer = document.createElement('div');
                  memberContainer.className = 'tree-children';

                  const sortedMembers = symbol.__members.sort((a, b) =>
                    a.label.localeCompare(b.label)
                  );

                  for (const member of sortedMembers) {
                    const memberItem = document.createElement('div');
                    memberItem.className = `tree-item tree-symbol tree-symbol-${member.type}`;
                    memberItem.style.paddingLeft = `${indentPadding + 30}px`;
                    memberItem.dataset.nodeId = member.id;
                    memberItem.innerHTML = `<span class="symbol-icon">${SYMBOL_ICONS[member.type] || 'â€¢'}</span> ${member.label}`;
                    memberItem.addEventListener('click', (e) => {
                      e.stopPropagation();
                      focusNode(member.id);
                    });
                    memberContainer.appendChild(memberItem);
                  }

                  symbolItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    symbolItem.classList.toggle('open');
                    memberContainer.classList.toggle('open');
                    focusNode(symbol.id);
                  });

                  fileChildren.appendChild(symbolItem);
                  fileChildren.appendChild(memberContainer);
                } else {
                  symbolItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    focusNode(symbol.id);
                  });
                  fileChildren.appendChild(symbolItem);
                }
              }
            }

            fileItem.addEventListener('click', () => {
              fileItem.classList.toggle('open');
              fileChildren.classList.toggle('open');
              focusNode(value.__nodeId);
            });

            container.appendChild(fileItem);
            if (value.__children && value.__children.length > 0) {
              container.appendChild(fileChildren);
            }
          } else {
            const folder = document.createElement('div');
            folder.className = 'tree-item tree-folder';
            folder.style.paddingLeft = `${indentPadding}px`;
            folder.textContent = name;

            const children = document.createElement('div');
            children.className = 'tree-children';

            folder.addEventListener('click', () => {
              folder.classList.toggle('open');
              children.classList.toggle('open');
            });

            container.appendChild(folder);
            container.appendChild(children);

            renderFileTree(value, children, depth + 1);
          }
        }
      }

      // Focus on a node in the graph and expand tree to show it
      function focusNode(nodeId, fromGraph = false) {
        const node = cy.getElementById(nodeId);
        if (node.length > 0) {
          // Clear previous selection
          cy.elements().unselect();
          document.querySelectorAll('.tree-item.selected').forEach((el) => {
            el.classList.remove('selected');
          });

          // Select and focus
          node.select();
          cy.animate({
            center: { eles: node },
            zoom: 1.5,
            duration: 300,
          });

          // Highlight in tree and expand parents
          const treeItem = document.querySelector(`[data-node-id="${nodeId}"]`);
          if (treeItem) {
            treeItem.classList.add('selected');

            // Expand all parent folders/files to make this visible
            let parent = treeItem.parentElement;
            while (parent) {
              if (parent.classList.contains('tree-children')) {
                parent.classList.add('open');
                const prevSibling = parent.previousElementSibling;
                if (
                  prevSibling &&
                  prevSibling.classList.contains('tree-item')
                ) {
                  prevSibling.classList.add('open');
                }
              }
              parent = parent.parentElement;
            }

            // Scroll tree item into view
            treeItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }

          // Show node info
          showNodeInfo(node.data());
        }
      }

      // Search functionality
      function setupSearch() {
        const searchInput = document.getElementById('search-input');
        const searchResults = document.getElementById('search-results');

        searchInput.addEventListener('input', (e) => {
          const query = e.target.value.toLowerCase().trim();

          // Clear previous highlights
          document.querySelectorAll('.tree-item.match').forEach((el) => {
            el.classList.remove('match');
          });
          cy.nodes().removeClass('highlighted');

          if (!query) {
            searchResults.textContent = '';
            return;
          }

          // Find matching nodes
          const matches = graphNodes.filter(
            (n) =>
              n.label.toLowerCase().includes(query) ||
              n.filePath.toLowerCase().includes(query)
          );

          searchResults.textContent = `${matches.length} result${matches.length !== 1 ? 's' : ''}`;

          // Highlight in tree
          for (const match of matches) {
            const treeItem = document.querySelector(
              `[data-node-id="${match.id}"]`
            );
            if (treeItem) {
              treeItem.classList.add('match');
              // Expand parent folders and files
              let parent = treeItem.parentElement;
              while (parent) {
                if (parent.classList.contains('tree-children')) {
                  parent.classList.add('open');
                  const prevSibling = parent.previousElementSibling;
                  if (prevSibling) {
                    prevSibling.classList.add('open');
                  }
                }
                parent = parent.parentElement;
              }
            }

            // Highlight in graph
            const node = cy.getElementById(match.id);
            if (node.length > 0) {
              node.addClass('highlighted');
            }
          }

          // Focus on first match if Enter is pressed
          if (matches.length > 0) {
            searchInput.onkeydown = (evt) => {
              if (evt.key === 'Enter') {
                focusNode(matches[0].id);
              } else if (evt.key === 'Escape') {
                searchInput.value = '';
                searchInput.dispatchEvent(new Event('input'));
              }
            };
          }
        });
      }

      async function init() {
        // Fetch graph data
        const response = await fetch('/api/graph');
        const graph = await response.json();

        // Store for search
        graphNodes = graph.nodes;

        document.getElementById('loading').style.display = 'none';
        document.getElementById('stats').textContent =
          `${graph.nodes.length} nodes, ${graph.edges.length} edges, ${graph.metadata.fileCount} files`;

        // Build and render file tree
        const tree = buildFileTree(graph.nodes);
        const treeContainer = document.getElementById('file-tree');
        renderFileTree(tree, treeContainer);

        // Convert to Cytoscape format
        const elements = [];

        // Add nodes
        for (const node of graph.nodes) {
          elements.push({
            data: {
              id: node.id,
              label: node.label,
              type: node.type,
              icon: SYMBOL_ICONS[node.type] || 'â€¢',
              filePath: node.filePath,
              line: node.line,
              column: node.column,
              metadata: node.metadata,
            },
          });
        }

        // Add edges - build a Set of node IDs for O(1) lookup
        const nodeIdSet = new Set(graph.nodes.map((n) => n.id));
        let skippedEdges = 0;

        for (const edge of graph.edges) {
          // Only add edge if both source and target exist
          const sourceExists = nodeIdSet.has(edge.source);
          const targetExists = nodeIdSet.has(edge.target);

          if (sourceExists && targetExists) {
            elements.push({
              data: {
                id: `${edge.source}->${edge.target}`,
                source: edge.source,
                target: edge.target,
                type: edge.type,
              },
            });
          } else {
            skippedEdges++;
          }
        }

        if (skippedEdges > 0) {
          console.log(
            '[graphts] Skipped',
            skippedEdges,
            'edges with missing nodes'
          );
        }

        // Initialize Cytoscape
        console.log(
          '[graphts] Initializing Cytoscape with',
          elements.length,
          'elements'
        );
        console.log(
          '[graphts] Nodes:',
          graph.nodes.length,
          '| Valid edges:',
          elements.length - graph.nodes.length
        );

        // Verify all edges reference existing nodes in elements
        const nodeElements = elements.filter((e) => !e.data.source);
        const elementNodeIds = new Set(nodeElements.map((e) => e.data.id));
        const edgeElements = elements.filter((e) => e.data.source);
        const orphanEdges = edgeElements.filter(
          (e) =>
            !elementNodeIds.has(e.data.source) ||
            !elementNodeIds.has(e.data.target)
        );
        if (orphanEdges.length > 0) {
          console.error(
            '[graphts] Still have orphan edges after filtering:',
            orphanEdges.length
          );
          orphanEdges.slice(0, 3).forEach((e) => {
            console.error('  Edge:', e.data.source, '->', e.data.target);
          });
          // Remove orphan edges from elements
          const validEdges = edgeElements.filter(
            (e) =>
              elementNodeIds.has(e.data.source) &&
              elementNodeIds.has(e.data.target)
          );
          elements.length = 0;
          elements.push(...nodeElements, ...validEdges);
          console.log('[graphts] After cleanup:', elements.length, 'elements');
        }

        // Try to initialize with dagre layout, fall back to cose if it fails
        let layoutName = 'dagre';
        let layoutOptions = {
          name: 'dagre',
          rankDir: 'TB',
          nodeSep: 30,
          rankSep: 100,
          edgeSep: 10,
          animate: false,
        };

        try {
          cy = cytoscape({
            container: document.getElementById('cy'),
            elements,
            style: [
              {
                selector: 'node',
                style: {
                  label: 'data(label)',
                  'background-color': (ele) =>
                    NODE_COLORS[ele.data('type')] || '#888',
                  color: '#fff',
                  'text-valign': 'bottom',
                  'text-halign': 'center',
                  'text-margin-y': 5,
                  'font-size': 10,
                  width: (ele) => (ele.data('type') === 'module' ? 30 : 22),
                  height: (ele) => (ele.data('type') === 'module' ? 30 : 22),
                  'border-width': 2,
                  'border-color': '#1a1a2e',
                  'text-outline-width': 1,
                  'text-outline-color': '#1a1a2e',
                  // Icon inside node using background
                  'background-image': (ele) => {
                    const icon = ele.data('icon') || 'â€¢';
                    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22"><text x="50%" y="55%" text-anchor="middle" dominant-baseline="middle" fill="white" font-family="Arial, sans-serif" font-size="12" font-weight="bold">${icon}</text></svg>`;
                    return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
                  },
                  'background-fit': 'contain',
                  'background-clip': 'none',
                },
              },
              {
                selector: 'node:selected',
                style: {
                  'border-width': 3,
                  'border-color': '#22d3ee',
                },
              },
              {
                selector: 'edge',
                style: {
                  width: 1,
                  'line-color': (ele) =>
                    EDGE_COLORS[ele.data('type')] || '#666',
                  'target-arrow-color': (ele) =>
                    EDGE_COLORS[ele.data('type')] || '#666',
                  'target-arrow-shape': 'triangle',
                  'curve-style': 'bezier',
                  opacity: 0.6,
                },
              },
              {
                selector: 'edge:selected',
                style: {
                  width: 2,
                  opacity: 1,
                },
              },
              {
                selector: '.hidden',
                style: {
                  display: 'none',
                },
              },
              {
                selector: '.highlighted',
                style: {
                  'border-width': 4,
                  'border-color': '#22d3ee',
                  'border-style': 'double',
                },
              },
            ],
            layout: layoutOptions,
            wheelSensitivity: 0.3,
          });
        } catch (e) {
          console.warn(
            '[graphts] Dagre layout failed, falling back to cose:',
            e.message
          );
          layoutName = 'cose';
          layoutOptions = { name: 'cose', animate: false };
          cy = cytoscape({
            container: document.getElementById('cy'),
            elements,
            style: [
              {
                selector: 'node',
                style: {
                  label: 'data(label)',
                  'background-color': (ele) =>
                    NODE_COLORS[ele.data('type')] || '#888',
                  color: '#fff',
                  'text-valign': 'bottom',
                  'text-halign': 'center',
                  'font-size': 10,
                  width: (ele) => (ele.data('type') === 'module' ? 30 : 22),
                  height: (ele) => (ele.data('type') === 'module' ? 30 : 22),
                },
              },
              {
                selector: 'edge',
                style: {
                  width: 1,
                  'line-color': (ele) =>
                    EDGE_COLORS[ele.data('type')] || '#666',
                  'target-arrow-color': (ele) =>
                    EDGE_COLORS[ele.data('type')] || '#666',
                  'target-arrow-shape': 'triangle',
                  'curve-style': 'bezier',
                  opacity: 0.6,
                },
              },
              { selector: '.hidden', style: { display: 'none' } },
            ],
            layout: layoutOptions,
            wheelSensitivity: 0.3,
          });
        }

        // Node click handler - also expand tree to show selected node
        cy.on('tap', 'node', (evt) => {
          const node = evt.target;
          focusNode(node.id(), true);
        });

        // Setup controls, search, and pattern filter
        setupControls();
        setupSearch();

        // Fetch filter config and setup pattern filter
        try {
          const configResponse = await fetch('/api/config');
          const config = await configResponse.json();
          console.log('[graphts] Fetched config:', config);
          setupPatternFilter(config);
        } catch (err) {
          console.error('[graphts] Failed to fetch config:', err);
          setupPatternFilter({});
        }

        // Setup sidebar toggles and orphan filter
        setupSidebarToggles();
        setupOrphanFilter();
      }

      function showNodeInfo(data) {
        const info = document.getElementById('node-info');
        const metadata = data.metadata || {};

        // Build TSDoc section
        let tsdocHtml = '';
        if (metadata.tsdoc) {
          tsdocHtml = `
            <div style="margin-top: 15px; padding: 10px; background: #0f3460; border-radius: 4px;">
              <div style="font-size: 11px; color: #888; margin-bottom: 5px; text-transform: uppercase;">Documentation</div>
              <div style="font-size: 12px; color: #ccc; white-space: pre-wrap; line-height: 1.5;">${escapeHtml(metadata.tsdoc)}</div>
            </div>
          `;
        }

        // Build methods section
        let methodsHtml = '';
        if (metadata.methods && metadata.methods.length > 0) {
          const methodsList = metadata.methods
            .map((m) => {
              const methodDoc = m.tsdoc
                ? `<div style="font-size: 11px; color: #888; margin-top: 3px; margin-left: 20px;">${escapeHtml(m.tsdoc.split('\n')[0])}</div>`
                : '';
              return `<div style="margin: 6px 0;"><span style="color: #2ecc71; font-family: monospace;">Æ’</span> <span style="color: #eee;">${escapeHtml(m.name)}</span>${methodDoc}</div>`;
            })
            .join('');

          methodsHtml = `
            <div style="margin-top: 15px; padding: 10px; background: #0f3460; border-radius: 4px;">
              <div style="font-size: 11px; color: #888; margin-bottom: 8px; text-transform: uppercase;">Public Methods</div>
              ${methodsList}
            </div>
          `;
        }

        // Use NODE_COLORS directly to ensure badge color matches node color
        const badgeColor = NODE_COLORS[data.type] || '#888';

        info.innerHTML = `
          <div class="label">${escapeHtml(data.label)}</div>
          <div class="type" style="background: ${badgeColor};">${data.type}</div>
          <div class="path">${escapeHtml(data.filePath)}</div>
          <div class="location">Line ${data.line}, Column ${data.column}</div>
          ${tsdocHtml}
          ${methodsHtml}
        `;
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      function setupControls() {
        // Layout selector
        document.getElementById('layout').addEventListener('change', (e) => {
          const layoutValue = e.target.value;
          const layoutOptions = {
            animate: true,
            animationDuration: 500,
          };

          // Configure layout based on selection
          if (layoutValue === 'dagre') {
            layoutOptions.name = 'dagre';
            layoutOptions.rankDir = 'TB';
            layoutOptions.nodeSep = 30;
            layoutOptions.rankSep = 100;
            layoutOptions.edgeSep = 10;
          } else if (layoutValue === 'dagre-lr') {
            layoutOptions.name = 'dagre';
            layoutOptions.rankDir = 'LR';
            layoutOptions.nodeSep = 30;
            layoutOptions.rankSep = 100;
            layoutOptions.edgeSep = 10;
          } else if (layoutValue === 'dagre-compact') {
            layoutOptions.name = 'dagre';
            layoutOptions.rankDir = 'TB';
            layoutOptions.nodeSep = 15;
            layoutOptions.rankSep = 50;
            layoutOptions.edgeSep = 5;
          } else if (layoutValue === 'concentric') {
            layoutOptions.name = 'concentric';
            layoutOptions.concentric = (node) => node.degree();
            layoutOptions.levelWidth = () => 2;
            layoutOptions.minNodeSpacing = 50;
          } else if (layoutValue === 'cose') {
            layoutOptions.name = 'cose';
            layoutOptions.nodeRepulsion = 8000;
            layoutOptions.idealEdgeLength = 100;
            layoutOptions.edgeElasticity = 100;
          } else {
            layoutOptions.name = layoutValue;
          }

          cy.layout(layoutOptions).run();
        });

        // Fit button
        document.getElementById('fit-btn').addEventListener('click', () => {
          cy.fit();
        });

        // Export button
        document.getElementById('export-btn').addEventListener('click', () => {
          const png = cy.png({ full: true, scale: 2 });
          const link = document.createElement('a');
          link.download = 'dependency-graph.png';
          link.href = png;
          link.click();
        });

        // Type filters via clickable legend items (nodes)
        document
          .querySelectorAll('#legend .legend-item.clickable')
          .forEach((item) => {
            item.addEventListener('click', () => {
              const type = item.dataset.type;
              const isActive = !item.classList.contains('inactive');

              // Toggle active state
              item.classList.toggle('inactive');

              cy.nodes().forEach((node) => {
                if (node.data('type') === type) {
                  if (isActive) {
                    node.addClass('hidden');
                  } else {
                    node.removeClass('hidden');
                  }
                }
              });

              // Update orphan filter if active
              updateOrphanVisibility();
            });
          });

        // Edge type filters via clickable legend items
        document
          .querySelectorAll('#edge-legend .legend-item.clickable')
          .forEach((item) => {
            item.addEventListener('click', () => {
              const edgeType = item.dataset.edgeType;
              const isActive = !item.classList.contains('inactive');

              // Toggle active state
              item.classList.toggle('inactive');

              cy.edges().forEach((edge) => {
                if (edge.data('type') === edgeType) {
                  if (isActive) {
                    edge.addClass('hidden');
                  } else {
                    edge.removeClass('hidden');
                  }
                }
              });

              // Update orphan filter based on visible edges
              updateOrphanVisibility();
            });
          });
      }

      // Global function to update orphan visibility based on current visible edges
      function updateOrphanVisibility() {
        const hideOrphansCheckbox = document.getElementById('hide-orphans');
        if (!hideOrphansCheckbox || !hideOrphansCheckbox.checked) return;

        // Re-apply orphan hiding based on currently visible edges
        cy.nodes().forEach((node) => {
          // Count only visible connected edges
          const visibleEdges = node
            .connectedEdges()
            .filter((e) => !e.hasClass('hidden'));
          const isOrphan = visibleEdges.length === 0;

          // Also check if node type is hidden
          const nodeType = node.data('type');
          const nodeTypeHidden = document
            .querySelector(`#legend .legend-item[data-type="${nodeType}"]`)
            ?.classList.contains('inactive');

          if (nodeTypeHidden) {
            node.addClass('hidden');
          } else if (isOrphan) {
            node.addClass('hidden');
          } else {
            node.removeClass('hidden');
          }
        });

        // Update stats
        const orphanStats = document.getElementById('orphan-stats');
        if (orphanStats) {
          const total = cy.nodes().length;
          const orphans = cy.nodes().filter((n) => {
            const visibleEdges = n
              .connectedEdges()
              .filter((e) => !e.hasClass('hidden'));
            return visibleEdges.length === 0;
          }).length;
          orphanStats.textContent = `${orphans} orphan nodes out of ${total} total`;
        }
      }

      function setupPatternFilter(config = {}) {
        console.log('[graphts] setupPatternFilter called with config:', config);

        const applyBtn = document.getElementById('apply-pattern-filter');
        const excludeInput = document.getElementById('exclude-patterns');
        const includeInput = document.getElementById('include-patterns');
        const filterStats = document.getElementById('filter-stats');

        if (!excludeInput || !includeInput || !applyBtn || !filterStats) {
          console.error('[graphts] Filter elements not found!', {
            applyBtn: !!applyBtn,
            excludeInput: !!excludeInput,
            includeInput: !!includeInput,
            filterStats: !!filterStats,
          });
          return;
        }

        // Set default values from CLI config
        if (config.exclude && config.exclude.length > 0) {
          excludeInput.value = config.exclude.join('\n');
          console.log('[graphts] Set exclude patterns:', config.exclude);
        }
        if (config.include && config.include.length > 0) {
          includeInput.value = config.include.join('\n');
          console.log('[graphts] Set include patterns:', config.include);
        }

        const applyFilter = () => {
          console.log('[graphts] applyFilter called');
          console.log(
            '[graphts] excludeInput.value:',
            JSON.stringify(excludeInput.value)
          );
          console.log(
            '[graphts] includeInput.value:',
            JSON.stringify(includeInput.value)
          );

          // Parse patterns from textareas
          const excludePatterns = excludeInput.value
            .split('\n')
            .map((p) => p.trim())
            .filter((p) => p.length > 0);
          const includePatterns = includeInput.value
            .split('\n')
            .map((p) => p.trim())
            .filter((p) => p.length > 0);

          console.log('[graphts] excludePatterns:', excludePatterns);
          console.log('[graphts] includePatterns:', includePatterns);
          console.log('[graphts] cy.nodes() count:', cy.nodes().length);

          let hiddenCount = 0;
          let shownCount = 0;

          cy.nodes().forEach((node) => {
            const filePath = node.data('filePath') || node.data('label') || '';
            const label = node.data('label') || '';

            // Check path against patterns (check both filePath and label)
            const pathToCheck = filePath || label;

            let shouldHide = false;

            // If include patterns exist, only show matching nodes
            if (includePatterns.length > 0) {
              if (!matchesPatterns(pathToCheck, includePatterns)) {
                shouldHide = true;
              }
            }

            // If exclude patterns exist and node wasn't already hidden, check exclusion
            if (!shouldHide && excludePatterns.length > 0) {
              if (matchesPatterns(pathToCheck, excludePatterns)) {
                shouldHide = true;
              }
            }

            if (shouldHide) {
              node.addClass('hidden');
              hiddenCount++;
            } else {
              node.removeClass('hidden');
              shownCount++;
            }
          });

          // Update filter stats
          if (excludePatterns.length > 0 || includePatterns.length > 0) {
            filterStats.textContent = `Showing ${shownCount} nodes, ${hiddenCount} hidden`;
          } else {
            filterStats.textContent = 'All nodes visible';
          }
          console.log('[graphts] Filter applied:', { shownCount, hiddenCount });
        };

        applyBtn.addEventListener('click', applyFilter);

        // Auto-apply if patterns are provided from CLI
        if (
          (config.exclude && config.exclude.length > 0) ||
          (config.include && config.include.length > 0)
        ) {
          console.log('[graphts] Auto-applying filter from CLI config');
          applyFilter();
        }
      }

      // Setup sidebar toggle buttons
      function setupSidebarToggles() {
        const leftClose = document.getElementById('left-close');
        const leftExpand = document.getElementById('left-expand');
        const rightClose = document.getElementById('right-close');
        const rightExpand = document.getElementById('right-expand');
        const leftSidebar = document.getElementById('left-sidebar');
        const sidebar = document.getElementById('sidebar');

        // Left sidebar close button
        leftClose.addEventListener('click', () => {
          leftSidebar.classList.add('collapsed');
          document.body.classList.add('left-collapsed');
          setTimeout(() => cy.resize(), 350);
        });

        // Left sidebar expand tab
        leftExpand.addEventListener('click', () => {
          leftSidebar.classList.remove('collapsed');
          document.body.classList.remove('left-collapsed');
          setTimeout(() => cy.resize(), 350);
        });

        // Right sidebar close button
        rightClose.addEventListener('click', () => {
          sidebar.classList.add('collapsed');
          document.body.classList.add('right-collapsed');
          setTimeout(() => cy.resize(), 350);
        });

        // Right sidebar expand tab
        rightExpand.addEventListener('click', () => {
          sidebar.classList.remove('collapsed');
          document.body.classList.remove('right-collapsed');
          setTimeout(() => cy.resize(), 350);
        });
      }

      // Setup orphan node filter
      function setupOrphanFilter() {
        const hideOrphansCheckbox = document.getElementById('hide-orphans');
        const orphanStats = document.getElementById('orphan-stats');

        // Count orphan nodes based on visible edges only
        const countOrphans = () => {
          let orphanCount = 0;
          cy.nodes().forEach((node) => {
            const visibleEdges = node
              .connectedEdges()
              .filter((e) => !e.hasClass('hidden'));
            if (visibleEdges.length === 0) {
              orphanCount++;
            }
          });
          return orphanCount;
        };

        const updateOrphanStats = () => {
          const total = cy.nodes().length;
          const orphans = countOrphans();
          orphanStats.textContent = `${orphans} orphan nodes out of ${total} total`;
        };

        updateOrphanStats();

        hideOrphansCheckbox.addEventListener('change', () => {
          const hideOrphans = hideOrphansCheckbox.checked;

          cy.nodes().forEach((node) => {
            // Check if node type is hidden
            const nodeType = node.data('type');
            const nodeTypeHidden = document
              .querySelector(`#legend .legend-item[data-type="${nodeType}"]`)
              ?.classList.contains('inactive');

            if (nodeTypeHidden) {
              // Keep hidden if type is hidden
              return;
            }

            // Count only visible connected edges
            const visibleEdges = node
              .connectedEdges()
              .filter((e) => !e.hasClass('hidden'));
            const isOrphan = visibleEdges.length === 0;

            if (isOrphan) {
              if (hideOrphans) {
                node.addClass('hidden');
              } else {
                node.removeClass('hidden');
              }
            }
          });

          updateOrphanStats();
        });
      }

      // Connect to SSE for watch mode updates
      function setupWatchMode() {
        const eventSource = new EventSource('/api/events');

        eventSource.addEventListener('connected', () => {
          console.log('Watch mode connected');
        });

        eventSource.addEventListener('update', () => {
          console.log('Graph updated, reloading...');
          // Re-fetch and update the graph
          fetch('/api/graph')
            .then((res) => res.json())
            .then((graph) => {
              // Update stats
              document.getElementById('stats').textContent =
                `${graph.nodes.length} nodes, ${graph.edges.length} edges, ${graph.metadata.fileCount} files`;

              // Rebuild elements
              const elements = [];

              for (const node of graph.nodes) {
                elements.push({
                  data: {
                    id: node.id,
                    label: node.label,
                    type: node.type,
                    icon: SYMBOL_ICONS[node.type] || 'â€¢',
                    filePath: node.filePath,
                    line: node.line,
                    column: node.column,
                    metadata: node.metadata,
                  },
                });
              }

              for (const edge of graph.edges) {
                const sourceExists = graph.nodes.some(
                  (n) => n.id === edge.source
                );
                const targetExists = graph.nodes.some(
                  (n) => n.id === edge.target
                );

                if (sourceExists && targetExists) {
                  elements.push({
                    data: {
                      id: `${edge.source}->${edge.target}`,
                      source: edge.source,
                      target: edge.target,
                      type: edge.type,
                    },
                  });
                }
              }

              // Update cytoscape
              cy.elements().remove();
              cy.add(elements);
              cy.layout({
                name: document.getElementById('layout').value,
                animate: false,
              }).run();
            })
            .catch(console.error);
        });

        eventSource.onerror = () => {
          console.log('Watch mode disconnected, will retry...');
        };
      }

      init()
        .then(() => {
          // Try to connect to watch mode (will fail gracefully if not enabled)
          setupWatchMode();
        })
        .catch(console.error);
    </script>
  </body>
</html>
