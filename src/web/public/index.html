<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>chizuts - Dependency Graph Visualizer</title>
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
    <script src="https://unpkg.com/cytoscape-fcose@2.2.0/cytoscape-fcose.js"></script>
    <!-- Cola: constraint-based layout with non-overlap guarantee -->
    <script src="https://unpkg.com/webcola@3.4.0/WebCola/cola.min.js"></script>
    <script src="https://unpkg.com/cytoscape-cola@2.5.1/cytoscape-cola.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #1a1a2e;
        color: #eee;
        overflow: hidden;
      }

      #header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 50px;
        background: #16213e;
        display: flex;
        align-items: center;
        padding: 0 20px;
        gap: 20px;
        z-index: 100;
        border-bottom: 1px solid #0f3460;
      }

      #header h1 {
        font-size: 18px;
        font-weight: 600;
        color: #22d3ee;
      }

      #stats {
        font-size: 14px;
        color: #888;
      }

      #controls {
        display: flex;
        gap: 10px;
        margin-left: auto;
      }

      button {
        background: #0f3460;
        color: #eee;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        transition: background 0.2s;
      }

      button:hover {
        background: #22d3ee;
        color: #1a1a2e;
      }

      select {
        background: #0f3460;
        color: #eee;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 13px;
      }

      #left-sidebar {
        position: fixed;
        top: 50px;
        left: 0;
        width: 280px;
        bottom: 0;
        background: #16213e;
        border-right: 1px solid #0f3460;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        transition:
          width 0.3s,
          transform 0.3s;
      }

      #left-sidebar.collapsed {
        width: 0;
        transform: translateX(-280px);
      }

      .sidebar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 6px 15px;
        margin-bottom: 10px;
        border-bottom: 1px solid #0f3460;
        background: #16213e;
      }

      .sidebar-header h3 {
        margin: 0;
        font-size: 12px;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .close-btn {
        width: 20px;
        height: 20px;
        background: transparent;
        border: none;
        color: #888;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        padding: 0;
        border-radius: 2px;
      }

      .close-btn:hover {
        color: #22d3ee;
        background: rgba(34, 211, 238, 0.1);
      }

      .expand-tab {
        position: fixed;
        top: 58px;
        padding: 6px 8px;
        background: #16213e;
        border: 1px solid #0f3460;
        color: #888;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 101;
      }

      .expand-tab:hover {
        color: #22d3ee;
        background: #0f3460;
      }

      #left-expand {
        left: 0;
        border-left: none;
        border-radius: 0 4px 4px 0;
      }

      #right-expand {
        right: 0;
        border-right: none;
        border-radius: 4px 0 0 4px;
      }

      body.left-collapsed #left-expand {
        display: flex;
      }

      body.right-collapsed #right-expand {
        display: flex;
      }

      #search-container {
        padding: 15px;
        border-bottom: 1px solid #0f3460;
      }

      #search-input {
        width: 100%;
        background: #0f3460;
        color: #eee;
        border: 1px solid #1a1a2e;
        padding: 10px 12px;
        border-radius: 4px;
        font-size: 13px;
        outline: none;
        transition: border-color 0.2s;
      }

      #search-input:focus {
        border-color: #22d3ee;
      }

      #search-input::placeholder {
        color: #666;
      }

      #search-results {
        font-size: 12px;
        color: #888;
        margin-top: 8px;
      }

      #file-tree-container {
        flex: 1;
        overflow-y: auto;
        padding: 10px 0;
      }

      .tree-item {
        padding: 6px 15px 6px 15px;
        font-size: 13px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: background 0.15s;
      }

      .tree-item:hover {
        background: #0f3460;
      }

      .tree-item.selected {
        background: #0891b2;
      }

      .tree-item.match {
        background: rgba(34, 211, 238, 0.3);
      }

      .tree-folder {
        color: #888;
        font-weight: 500;
      }

      .tree-folder::before {
        content: 'ðŸ“';
        font-size: 12px;
      }

      .tree-folder.open::before {
        content: 'ðŸ“‚';
      }

      .tree-file::before {
        content: 'M';
        display: inline-block;
        width: 16px;
        height: 16px;
        line-height: 16px;
        text-align: center;
        border-radius: 3px;
        font-size: 10px;
        font-weight: bold;
        background: #3498db;
        color: #fff;
        margin-right: 4px;
      }

      .tree-symbol {
        color: #ccc;
      }

      .symbol-icon {
        display: inline-block;
        width: 16px;
        height: 16px;
        line-height: 16px;
        text-align: center;
        border-radius: 3px;
        font-size: 10px;
        font-weight: bold;
        margin-right: 4px;
      }

      .tree-symbol-function .symbol-icon {
        background: #2ecc71;
        color: #fff;
      }

      .tree-symbol-class .symbol-icon {
        background: #9b59b6;
        color: #fff;
      }

      .tree-symbol-variable .symbol-icon {
        background: #f39c12;
        color: #fff;
      }

      .tree-symbol-component .symbol-icon {
        background: #e74c3c;
        color: #fff;
      }

      .tree-symbol-interface .symbol-icon {
        background: #1abc9c;
        color: #fff;
      }

      .tree-symbol-type .symbol-icon {
        background: #e67e22;
        color: #fff;
      }

      .tree-symbol-enum .symbol-icon {
        background: #8e44ad;
        color: #fff;
      }

      .tree-symbol-method .symbol-icon {
        background: #27ae60;
        color: #fff;
      }

      .tree-symbol-field .symbol-icon {
        background: #d35400;
        color: #fff;
      }

      .tree-children {
        display: none;
      }

      .tree-children.open {
        display: block;
      }

      /* Dynamic indentation - base padding + depth * 15px */

      #cy {
        position: fixed;
        top: 50px;
        left: 280px;
        right: 300px;
        bottom: 0;
        transition:
          left 0.3s,
          right 0.3s;
      }

      body.left-collapsed #cy {
        left: 0;
      }

      body.right-collapsed #cy {
        right: 0;
      }

      #sidebar {
        position: fixed;
        top: 50px;
        right: 0;
        width: 300px;
        bottom: 0;
        background: #16213e;
        border-left: 1px solid #0f3460;
        overflow-y: auto;
        transition:
          width 0.3s,
          transform 0.3s;
      }

      #sidebar.collapsed {
        width: 0;
        transform: translateX(300px);
        overflow: hidden;
      }

      #sidebar > h2,
      #sidebar > #node-info,
      #sidebar > #orphan-filter,
      #sidebar > #pattern-filter {
        padding-left: 20px;
        padding-right: 20px;
      }

      .legend-container {
        display: flex;
        gap: 10px;
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #0f3460;
      }

      .legend-container #legend {
        flex: 1;
        min-width: 0;
        padding-left: 20px;
      }

      .legend-container #edge-legend {
        flex: 1;
        min-width: 0;
        padding-right: 20px;
      }

      .legend-container #legend h2,
      .legend-container #edge-legend h2 {
        font-size: 12px;
        margin-top: 0;
      }

      #sidebar h2 {
        font-size: 14px;
        color: #888;
        margin-top: 15px;
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      #node-info {
        font-size: 13px;
        line-height: 1.6;
      }

      #node-info .label {
        color: #22d3ee;
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 10px;
      }

      #node-info .type {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 3px;
        font-size: 11px;
        text-transform: uppercase;
        margin-bottom: 15px;
      }

      /* TYPE badge colors are set dynamically from NODE_COLORS in JavaScript */

      #node-info .path {
        color: #888;
        font-family: monospace;
        font-size: 12px;
        word-break: break-all;
      }

      #node-info .location {
        color: #666;
        font-size: 12px;
        margin-top: 5px;
      }

      #filter-section {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #0f3460;
      }

      #filter-section label {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 8px 0;
        cursor: pointer;
        font-size: 13px;
      }

      #filter-section input[type='checkbox'] {
        width: 16px;
        height: 16px;
      }

      #node-legend {
        padding-top: 0px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 6px 0;
        font-size: 12px;
      }

      .legend-item.clickable {
        cursor: pointer;
        padding: 4px 8px;
        margin: 4px -8px;
        border-radius: 4px;
        transition:
          background 0.15s,
          opacity 0.15s;
      }

      .legend-item.clickable:hover {
        background: #0f3460;
      }

      .legend-item.clickable.inactive {
        opacity: 0.4;
      }

      .legend-item.clickable.inactive .legend-color,
      .legend-item.clickable.inactive .legend-line {
        background: #555 !important;
      }

      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 2px;
      }

      .legend-line {
        width: 20px;
        height: 3px;
        border-radius: 1px;
      }

      #edge-legend {
        padding-top: 0px;
      }

      #pattern-filter {
        margin-top: 20px;
        padding-top: 0px;
        border-top: 1px solid #0f3460;
      }

      #pattern-filter h2 {
        font-size: 14px;
        color: #888;
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      #loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 18px;
        color: #888;
      }
    </style>
  </head>
  <body>
    <div id="header">
      <h1>chizuts</h1>
      <span id="stats">Loading...</span>
      <div id="controls">
        <select id="layout">
          <option value="cola" selected>Cola</option>
          <option value="fcose">fCoSE</option>
          <option value="cose">CoSE</option>
          <option value="dagre">Dagre (top-bottom)</option>
          <option value="dagre-lr">Dagre (left-right)</option>
          <option value="dagre-compact">Dagre (compact)</option>
          <option value="breadthfirst">Breadthfirst</option>
          <option value="concentric">Concentric</option>
          <option value="circle">Circle</option>
          <option value="grid">Grid</option>
        </select>
        <button id="fit-btn">Fit to Screen</button>
        <button id="save-layout-btn">Save Layout</button>
        <button id="export-btn">Export PNG</button>
      </div>
    </div>

    <button id="left-expand" class="expand-tab" title="Show file tree">
      FILES
    </button>
    <button id="right-expand" class="expand-tab" title="Show details">
      DETAILS
    </button>

    <div id="left-sidebar">
      <div class="sidebar-header">
        <h3>Files</h3>
        <button id="left-close" class="close-btn" title="Hide file tree">
          &times;
        </button>
      </div>
      <div id="search-container">
        <input
          type="text"
          id="search-input"
          placeholder="Search files..."
          autocomplete="off"
        />
        <div id="search-results"></div>
      </div>
      <div id="file-tree-container">
        <div id="file-tree"></div>
      </div>
    </div>

    <div id="cy"></div>

    <div id="sidebar">
      <div class="sidebar-header">
        <h3>Details</h3>
        <button id="right-close" class="close-btn" title="Hide details">
          &times;
        </button>
      </div>
      <h2>Symbol Details</h2>
      <div id="node-info">
        <p style="color: #666">Click a symbol to see details</p>
      </div>

      <div class="legend-container">
        <div id="legend">
          <h2>Symbols</h2>
          <div class="legend-item clickable" data-type="module">
            <div class="legend-color" style="background: #3498db"></div>
            Module
          </div>
          <div class="legend-item clickable" data-type="function">
            <div class="legend-color" style="background: #2ecc71"></div>
            Function
          </div>
          <div class="legend-item clickable" data-type="class">
            <div class="legend-color" style="background: #9b59b6"></div>
            Class
          </div>
          <div class="legend-item clickable" data-type="variable">
            <div class="legend-color" style="background: #f39c12"></div>
            Variable
          </div>
          <div class="legend-item clickable" data-type="component">
            <div class="legend-color" style="background: #e74c3c"></div>
            Component
          </div>
          <div class="legend-item clickable" data-type="interface">
            <div class="legend-color" style="background: #1abc9c"></div>
            Interface
          </div>
          <div class="legend-item clickable" data-type="type">
            <div class="legend-color" style="background: #e67e22"></div>
            Type
          </div>
          <div class="legend-item clickable" data-type="enum">
            <div class="legend-color" style="background: #8e44ad"></div>
            Enum
          </div>
          <div class="legend-item clickable" data-type="method">
            <div class="legend-color" style="background: #27ae60"></div>
            Method
          </div>
          <div class="legend-item clickable" data-type="field">
            <div class="legend-color" style="background: #d35400"></div>
            Field
          </div>
        </div>

        <div id="edge-legend">
          <h2>Relations</h2>
          <div class="legend-item clickable" data-edge-type="import">
            <div class="legend-line" style="background: #3498db"></div>
            import
          </div>
          <div class="legend-item clickable" data-edge-type="call">
            <div class="legend-line" style="background: #e74c3c"></div>
            call
          </div>
          <div class="legend-item clickable" data-edge-type="reference">
            <div class="legend-line" style="background: #f39c12"></div>
            reference
          </div>
          <div class="legend-item clickable" data-edge-type="extends">
            <div class="legend-line" style="background: #9b59b6"></div>
            extends
          </div>
          <div class="legend-item clickable" data-edge-type="implements">
            <div class="legend-line" style="background: #e91e63"></div>
            implements
          </div>
        </div>
      </div>

      <div
        id="orphan-filter"
        style="
          margin-top: 20px;
          padding-top: 0px;
          border-top: 1px solid #0f3460;
        "
      >
        <h2>Display Options</h2>
        <label
          style="
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
            cursor: pointer;
            font-size: 13px;
          "
        >
          <input
            type="checkbox"
            id="hide-orphans"
            style="width: 16px; height: 16px"
          />
          Hide orphan symbols (no connections)
        </label>
        <div
          id="orphan-stats"
          style="font-size: 11px; color: #888; margin-top: 4px"
        ></div>
      </div>

      <div id="pattern-filter">
        <h2>Pattern Filter</h2>
        <div style="margin-bottom: 10px">
          <label
            style="
              font-size: 12px;
              color: #888;
              display: block;
              margin-bottom: 4px;
            "
            >Exclude patterns (one per line)</label
          >
          <textarea
            id="exclude-patterns"
            placeholder="*test*&#10;*.spec.*&#10;__mocks__/*"
            rows="3"
            style="
              width: 100%;
              background: #0f3460;
              color: #eee;
              border: 1px solid #1a1a2e;
              border-radius: 4px;
              padding: 8px;
              font-size: 12px;
              font-family: monospace;
              resize: vertical;
            "
          ></textarea>
        </div>
        <div style="margin-bottom: 10px">
          <label
            style="
              font-size: 12px;
              color: #888;
              display: block;
              margin-bottom: 4px;
            "
            >Include patterns (empty = all)</label
          >
          <textarea
            id="include-patterns"
            placeholder="src/*&#10;*.ts"
            rows="2"
            style="
              width: 100%;
              background: #0f3460;
              color: #eee;
              border: 1px solid #1a1a2e;
              border-radius: 4px;
              padding: 8px;
              font-size: 12px;
              font-family: monospace;
              resize: vertical;
            "
          ></textarea>
        </div>
        <button id="apply-pattern-filter" style="width: 100%">
          Apply Filter
        </button>
        <div
          id="filter-stats"
          style="font-size: 11px; color: #888; margin-top: 8px"
        ></div>
      </div>
    </div>

    <div id="loading">Loading graph...</div>

    <script>
      const NODE_COLORS = {
        module: '#3498db',
        function: '#2ecc71',
        class: '#9b59b6',
        variable: '#f39c12',
        component: '#e74c3c',
        interface: '#1abc9c',
        type: '#e67e22',
        enum: '#8e44ad',
        method: '#27ae60',
        field: '#d35400',
      };

      const EDGE_COLORS = {
        import: '#3498db',
        export: '#7f8c8d', // "defines" - module contains this symbol
        call: '#e74c3c',
        reference: '#f39c12',
        extends: '#9b59b6',
        implements: '#e91e63', // pink - distinct from green
      };

      // LocalStorage keys for persistence
      const STORAGE_KEYS = {
        hiddenNodeTypes: 'chizuts_hiddenNodeTypes',
        hiddenEdgeTypes: 'chizuts_hiddenEdgeTypes',
        hideOrphans: 'chizuts_hideOrphans',
        excludePatterns: 'chizuts_excludePatterns',
        includePatterns: 'chizuts_includePatterns',
        selectedLayout: 'chizuts_selectedLayout',
      };

      // Save state to localStorage
      function saveState(key, value) {
        try {
          localStorage.setItem(key, JSON.stringify(value));
        } catch (e) {
          console.warn('[chizuts] Failed to save state:', e);
        }
      }

      // Load state from localStorage
      function loadState(key, defaultValue = null) {
        try {
          const stored = localStorage.getItem(key);
          return stored ? JSON.parse(stored) : defaultValue;
        } catch (e) {
          console.warn('[chizuts] Failed to load state:', e);
          return defaultValue;
        }
      }

      let cy;
      let graphNodes = [];

      // Build directory tree from relative file paths with child symbols
      function buildFileTree(nodes) {
        const tree = {};

        // Get modules and their children
        const modules = nodes.filter((n) => n.type === 'module');
        const topLevelSymbols = nodes.filter(
          (n) =>
            n.type !== 'module' && n.type !== 'method' && n.type !== 'field'
        );
        const memberSymbols = nodes.filter(
          (n) => n.type === 'method' || n.type === 'field'
        );

        // Build module tree
        for (const node of modules) {
          const parts = node.label.split('/').filter(Boolean);
          let current = tree;

          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            const isFile = i === parts.length - 1;

            if (!current[part]) {
              current[part] = isFile
                ? {
                    __isFile: true,
                    __nodeId: node.id,
                    __label: node.label,
                    __children: [],
                  }
                : {};
            }
            current = current[part];
          }
        }

        // Add top-level symbols to their parent modules
        for (const symbol of topLevelSymbols) {
          // Find parent module by matching file path
          const parentModule = modules.find((m) =>
            symbol.id.startsWith(m.id + '#')
          );
          if (parentModule) {
            const parts = parentModule.label.split('/').filter(Boolean);
            let current = tree;

            for (const part of parts) {
              if (current[part]) {
                current = current[part];
              }
            }

            if (current.__children) {
              current.__children.push({
                id: symbol.id,
                label: symbol.label,
                type: symbol.type,
                __members: [], // For classes to hold methods/fields
              });
            }
          }
        }

        // Add methods/fields to their parent class
        for (const member of memberSymbols) {
          // Member ID format: module#ClassName.memberName
          // Find parent class by checking if class ID is prefix of member ID
          const parentClass = topLevelSymbols.find(
            (s) => s.type === 'class' && member.id.startsWith(s.id + '.')
          );
          if (parentClass) {
            // Find the class in the tree and add the member
            const parentModule = modules.find((m) =>
              parentClass.id.startsWith(m.id + '#')
            );
            if (parentModule) {
              const parts = parentModule.label.split('/').filter(Boolean);
              let current = tree;

              for (const part of parts) {
                if (current[part]) {
                  current = current[part];
                }
              }

              if (current.__children) {
                const classEntry = current.__children.find(
                  (c) => c.id === parentClass.id
                );
                if (classEntry && classEntry.__members) {
                  classEntry.__members.push({
                    id: member.id,
                    label: member.label,
                    type: member.type,
                  });
                }
              }
            }
          }
        }

        return tree;
      }

      // Convert glob pattern to regex
      function globToRegex(glob) {
        // Escape special regex characters except * and ?
        let regex = glob
          .replace(/[.+^${}()|[\]\\]/g, '\\$&')
          // Convert ** to match anything including /
          .replace(/\*\*/g, '.*')
          // Convert * to match anything except /
          .replace(/\*/g, '[^/]*')
          // Convert ? to match single character
          .replace(/\?/g, '.');
        return new RegExp(regex, 'i');
      }

      // Check if a path matches any of the patterns
      function matchesPatterns(path, patterns) {
        if (!patterns || patterns.length === 0) return false;
        return patterns.some((pattern) => {
          try {
            const regex = globToRegex(pattern);
            return regex.test(path);
          } catch (e) {
            return false;
          }
        });
      }

      // Symbol type icons
      const SYMBOL_ICONS = {
        module: 'M',
        function: 'Æ’',
        class: 'C',
        variable: 'V',
        component: 'âš›',
        interface: 'I',
        type: 'T',
        enum: 'E',
        method: 'm',
        field: 'f',
      };

      // Render the file tree
      function renderFileTree(tree, container, depth = 0) {
        const entries = Object.entries(tree).sort(([a, aVal], [b, bVal]) => {
          // Folders first, then files
          const aIsFile = aVal.__isFile;
          const bIsFile = bVal.__isFile;
          if (aIsFile !== bIsFile) return aIsFile ? 1 : -1;
          return a.localeCompare(b);
        });

        for (const [name, value] of entries) {
          if (name.startsWith('__')) continue;

          const isFile = value.__isFile;
          const indentPadding = 15 + depth * 15; // Base 15px + 15px per depth level

          if (isFile) {
            const fileItem = document.createElement('div');
            fileItem.className = 'tree-item tree-file';
            fileItem.style.paddingLeft = `${indentPadding}px`;
            fileItem.textContent = name;
            fileItem.dataset.nodeId = value.__nodeId;

            const fileChildren = document.createElement('div');
            fileChildren.className = 'tree-children';

            // Render symbol children
            if (value.__children && value.__children.length > 0) {
              const sortedSymbols = value.__children.sort((a, b) =>
                a.label.localeCompare(b.label)
              );

              for (const symbol of sortedSymbols) {
                const symbolItem = document.createElement('div');
                symbolItem.className = `tree-item tree-symbol tree-symbol-${symbol.type}`;
                symbolItem.style.paddingLeft = `${indentPadding + 15}px`;
                symbolItem.dataset.nodeId = symbol.id;
                symbolItem.innerHTML = `<span class="symbol-icon">${SYMBOL_ICONS[symbol.type] || 'â€¢'}</span> ${symbol.label}`;

                // If symbol has members (class with methods/fields), make it expandable
                if (symbol.__members && symbol.__members.length > 0) {
                  const memberContainer = document.createElement('div');
                  memberContainer.className = 'tree-children';

                  const sortedMembers = symbol.__members.sort((a, b) =>
                    a.label.localeCompare(b.label)
                  );

                  for (const member of sortedMembers) {
                    const memberItem = document.createElement('div');
                    memberItem.className = `tree-item tree-symbol tree-symbol-${member.type}`;
                    memberItem.style.paddingLeft = `${indentPadding + 30}px`;
                    memberItem.dataset.nodeId = member.id;
                    memberItem.innerHTML = `<span class="symbol-icon">${SYMBOL_ICONS[member.type] || 'â€¢'}</span> ${member.label}`;
                    memberItem.addEventListener('click', (e) => {
                      e.stopPropagation();
                      focusNode(member.id);
                    });
                    memberContainer.appendChild(memberItem);
                  }

                  symbolItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    symbolItem.classList.toggle('open');
                    memberContainer.classList.toggle('open');
                    focusNode(symbol.id);
                  });

                  fileChildren.appendChild(symbolItem);
                  fileChildren.appendChild(memberContainer);
                } else {
                  symbolItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    focusNode(symbol.id);
                  });
                  fileChildren.appendChild(symbolItem);
                }
              }
            }

            fileItem.addEventListener('click', () => {
              fileItem.classList.toggle('open');
              fileChildren.classList.toggle('open');
              focusNode(value.__nodeId);
            });

            container.appendChild(fileItem);
            if (value.__children && value.__children.length > 0) {
              container.appendChild(fileChildren);
            }
          } else {
            const folder = document.createElement('div');
            folder.className = 'tree-item tree-folder';
            folder.style.paddingLeft = `${indentPadding}px`;
            folder.textContent = name;

            const children = document.createElement('div');
            children.className = 'tree-children';

            folder.addEventListener('click', () => {
              folder.classList.toggle('open');
              children.classList.toggle('open');
            });

            container.appendChild(folder);
            container.appendChild(children);

            renderFileTree(value, children, depth + 1);
          }
        }
      }

      // Focus on a node in the graph and expand tree to show it
      function focusNode(nodeId, fromGraph = false) {
        const node = cy.getElementById(nodeId);
        if (node.length > 0) {
          // Clear previous selection
          cy.elements().unselect();
          document.querySelectorAll('.tree-item.selected').forEach((el) => {
            el.classList.remove('selected');
          });

          // Select node (no auto-centering/zooming)
          node.select();

          // Highlight in tree and expand parents
          const treeItem = document.querySelector(`[data-node-id="${nodeId}"]`);
          if (treeItem) {
            treeItem.classList.add('selected');

            // Expand all parent folders/files to make this visible
            let parent = treeItem.parentElement;
            while (parent) {
              if (parent.classList.contains('tree-children')) {
                parent.classList.add('open');
                const prevSibling = parent.previousElementSibling;
                if (
                  prevSibling &&
                  prevSibling.classList.contains('tree-item')
                ) {
                  prevSibling.classList.add('open');
                }
              }
              parent = parent.parentElement;
            }

            // Scroll tree item into view
            treeItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }

          // Show node info
          showNodeInfo(node.data());
        }
      }

      // Search functionality
      function setupSearch() {
        const searchInput = document.getElementById('search-input');
        const searchResults = document.getElementById('search-results');

        searchInput.addEventListener('input', (e) => {
          const query = e.target.value.toLowerCase().trim();

          // Clear previous highlights
          document.querySelectorAll('.tree-item.match').forEach((el) => {
            el.classList.remove('match');
          });
          cy.nodes().removeClass('highlighted');

          if (!query) {
            searchResults.textContent = '';
            return;
          }

          // Find matching nodes
          const matches = graphNodes.filter(
            (n) =>
              n.label.toLowerCase().includes(query) ||
              n.filePath.toLowerCase().includes(query)
          );

          searchResults.textContent = `${matches.length} result${matches.length !== 1 ? 's' : ''}`;

          // Highlight in tree
          for (const match of matches) {
            const treeItem = document.querySelector(
              `[data-node-id="${match.id}"]`
            );
            if (treeItem) {
              treeItem.classList.add('match');
              // Expand parent folders and files
              let parent = treeItem.parentElement;
              while (parent) {
                if (parent.classList.contains('tree-children')) {
                  parent.classList.add('open');
                  const prevSibling = parent.previousElementSibling;
                  if (prevSibling) {
                    prevSibling.classList.add('open');
                  }
                }
                parent = parent.parentElement;
              }
            }

            // Highlight in graph
            const node = cy.getElementById(match.id);
            if (node.length > 0) {
              node.addClass('highlighted');
            }
          }

          // Focus on first match if Enter is pressed
          if (matches.length > 0) {
            searchInput.onkeydown = (evt) => {
              if (evt.key === 'Enter') {
                focusNode(matches[0].id);
              } else if (evt.key === 'Escape') {
                searchInput.value = '';
                searchInput.dispatchEvent(new Event('input'));
              }
            };
          }
        });
      }

      // Save current layout positions to the server
      async function saveLayout() {
        const positions = {};
        cy.nodes().forEach((node) => {
          const pos = node.position();
          positions[node.id()] = { x: pos.x, y: pos.y };
        });

        try {
          const response = await fetch('/api/layout', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              positions,
              savedAt: new Date().toISOString(),
            }),
          });

          if (response.ok) {
            const result = await response.json();
            console.log('[chizuts] Layout saved:', result.path);
            alert('Layout saved successfully!');
          } else {
            const error = await response.json();
            console.error('[chizuts] Failed to save layout:', error);
            alert('Failed to save layout: ' + error.error);
          }
        } catch (err) {
          console.error('[chizuts] Error saving layout:', err);
          alert('Error saving layout');
        }
      }

      // Load saved layout positions from the server
      async function loadSavedLayout() {
        try {
          const response = await fetch('/api/layout');
          if (response.ok) {
            const data = await response.json();
            console.log(
              '[chizuts] Loaded saved layout:',
              Object.keys(data.positions || {}).length,
              'positions'
            );
            return data.positions || {};
          }
        } catch (err) {
          console.error('[chizuts] Error loading layout:', err);
        }
        return {};
      }

      async function init() {
        // Fetch graph data and saved layout in parallel
        const [graphResponse, savedPositions] = await Promise.all([
          fetch('/api/graph'),
          loadSavedLayout(),
        ]);
        const graph = await graphResponse.json();

        // Store for search
        graphNodes = graph.nodes;

        document.getElementById('loading').style.display = 'none';
        document.getElementById('stats').textContent =
          `${graph.nodes.length} symbols, ${graph.edges.length} relations, ${graph.metadata.fileCount} files`;

        // Build and render file tree
        const tree = buildFileTree(graph.nodes);
        const treeContainer = document.getElementById('file-tree');
        renderFileTree(tree, treeContainer);

        // Convert to Cytoscape format
        const elements = [];

        // Build module ID lookup for parent assignment
        const moduleIds = new Set(
          graph.nodes.filter((n) => n.type === 'module').map((n) => n.id)
        );

        // Build class ID lookup for parent assignment (classes are also compound nodes)
        const classIds = new Set(
          graph.nodes.filter((n) => n.type === 'class').map((n) => n.id)
        );

        // Helper to find parent ID from a node ID
        // For methods/fields: parent is the class
        // For classes/functions/etc: parent is the module
        function getParentId(nodeId) {
          if (!nodeId.includes('#')) return null;
          const symbolPart = nodeId.split('#')[1]; // e.g., "FileReaderAdapter.findFiles"

          // Check if this is a class member (contains '.')
          if (symbolPart && symbolPart.includes('.')) {
            // Extract class name: "ClassName.methodName" -> "ClassName"
            const className = symbolPart.split('.')[0];
            const moduleId = nodeId.split('#')[0];
            const classId = `${moduleId}#${className}`;
            if (classIds.has(classId)) {
              return classId; // Parent is the class
            }
          }

          // Otherwise, parent is the module
          const moduleId = nodeId.split('#')[0];
          return moduleIds.has(moduleId) ? moduleId : null;
        }

        // Add nodes (modules first, then classes, then children)
        // Sort so container nodes are added before their children
        const sortedNodes = [...graph.nodes].sort((a, b) => {
          const order = { module: 0, class: 1 };
          const aOrder = order[a.type] ?? 2;
          const bOrder = order[b.type] ?? 2;
          return aOrder - bOrder;
        });

        for (const node of sortedNodes) {
          const parentId = getParentId(node.id);
          elements.push({
            data: {
              id: node.id,
              label: node.label,
              type: node.type,
              icon: SYMBOL_ICONS[node.type] || 'â€¢',
              filePath: node.filePath,
              line: node.line,
              column: node.column,
              metadata: node.metadata,
              parent: parentId, // For compound nodes
            },
          });
        }

        // Add edges - build a Set of node IDs for O(1) lookup
        const nodeIdSet = new Set(graph.nodes.map((n) => n.id));
        let skippedEdges = 0;
        let skippedDefinedEdges = 0;

        for (const edge of graph.edges) {
          // Only add edge if both source and target exist
          const sourceExists = nodeIdSet.has(edge.source);
          const targetExists = nodeIdSet.has(edge.target);

          // Skip edges from container to its children (redundant with compound nodes)
          // This includes "export" edges which indicate module/class defines a symbol
          // 1. Module -> direct children (e.g., module#Symbol)
          if (
            moduleIds.has(edge.source) &&
            edge.target.startsWith(edge.source + '#') &&
            !edge.target.slice(edge.source.length + 1).includes('.')
          ) {
            skippedDefinedEdges++;
            continue;
          }
          // 2. Class -> methods/fields (e.g., module#Class -> module#Class.method)
          if (
            classIds.has(edge.source) &&
            edge.target.startsWith(edge.source + '.')
          ) {
            skippedDefinedEdges++;
            continue;
          }

          if (sourceExists && targetExists) {
            elements.push({
              data: {
                id: `${edge.source}->${edge.target}`,
                source: edge.source,
                target: edge.target,
                type: edge.type,
              },
            });
          } else {
            skippedEdges++;
          }
        }

        if (skippedDefinedEdges > 0) {
          console.log(
            '[chizuts] Hidden',
            skippedDefinedEdges,
            'container->child edges (redundant with compound nodes)'
          );
        }

        if (skippedEdges > 0) {
          console.log(
            '[chizuts] Skipped',
            skippedEdges,
            'edges with missing nodes'
          );
        }

        // Initialize Cytoscape
        console.log(
          '[chizuts] Initializing Cytoscape with',
          elements.length,
          'elements'
        );
        console.log(
          '[chizuts] Nodes:',
          graph.nodes.length,
          '| Valid edges:',
          elements.length - graph.nodes.length
        );

        // Verify all edges reference existing nodes in elements
        const nodeElements = elements.filter((e) => !e.data.source);
        const elementNodeIds = new Set(nodeElements.map((e) => e.data.id));
        const edgeElements = elements.filter((e) => e.data.source);
        const orphanEdges = edgeElements.filter(
          (e) =>
            !elementNodeIds.has(e.data.source) ||
            !elementNodeIds.has(e.data.target)
        );
        if (orphanEdges.length > 0) {
          console.error(
            '[chizuts] Still have orphan edges after filtering:',
            orphanEdges.length
          );
          orphanEdges.slice(0, 3).forEach((e) => {
            console.error('  Edge:', e.data.source, '->', e.data.target);
          });
          // Remove orphan edges from elements
          const validEdges = edgeElements.filter(
            (e) =>
              elementNodeIds.has(e.data.source) &&
              elementNodeIds.has(e.data.target)
          );
          elements.length = 0;
          elements.push(...nodeElements, ...validEdges);
          console.log('[chizuts] After cleanup:', elements.length, 'elements');
        }

        // Check how many nodes have saved positions
        const savedPositionCount = Object.keys(savedPositions).length;
        const nodesWithSavedPositions = new Set();
        const nodesWithoutSavedPositions = [];

        // Apply saved positions to elements and track which nodes are new
        for (const element of elements) {
          if (element.data && !element.data.source) {
            // This is a node
            const nodeId = element.data.id;
            if (savedPositions[nodeId]) {
              element.position = savedPositions[nodeId];
              nodesWithSavedPositions.add(nodeId);
            } else {
              nodesWithoutSavedPositions.push(nodeId);
            }
          }
        }

        console.log(
          '[chizuts] Nodes with saved positions:',
          nodesWithSavedPositions.size
        );
        console.log(
          '[chizuts] New nodes without positions:',
          nodesWithoutSavedPositions.length
        );

        // Use Cola layout - constraint-based with guaranteed non-overlap
        // Goals: (1) no module overlap, (2) no label overlap,
        // (3) minimize module area, (4) minimize total edge length
        let layoutName = 'cola';

        // Check available layout extensions
        if (typeof cytoscape !== 'undefined') {
          console.log('[chizuts] cytoscape version:', cytoscape.version);
          console.log('[chizuts] cola available:', typeof cola !== 'undefined');
        }

        // If we have saved positions, use preset layout; otherwise use cola
        const hasSavedPositions = savedPositionCount > 0;

        let layoutOptions = hasSavedPositions
          ? {
              name: 'preset',
              fit: true,
              padding: 30,
            }
          : {
              name: 'cola',
              animate: false,
              fit: true,
              padding: 30,
              // CONSTRAINT: prevent node overlap (guaranteed)
              avoidOverlap: true,
              // Edge length - minimize by setting small value
              edgeLength: (edge) => 60,
              // Node spacing - extra space between nodes
              nodeSpacing: 10,
              // Flow direction for better hierarchy (optional)
              flow: { axis: 'y', minSeparation: 30 },
              // Convergence threshold - lower = more iterations for better result
              convergenceThreshold: 0.01,
              // Handle disconnected components
              handleDisconnected: true,
              // Randomize for better initial positions
              randomize: true,
              // Max simulation time (ms)
              maxSimulationTime: 4000,
              // Unconstraint iteration for initial layout
              unconstrIter: 10,
              // User constraint iterations
              userConstIter: 20,
              // All constraints iterations
              allConstIter: 20,
            };

        try {
          cy = cytoscape({
            container: document.getElementById('cy'),
            elements,
            style: [
              // Child nodes (non-module symbols)
              {
                selector: 'node[type != "module"]',
                style: {
                  label: 'data(label)',
                  'background-color': (ele) =>
                    NODE_COLORS[ele.data('type')] || '#888',
                  color: '#fff',
                  'text-valign': 'bottom',
                  'text-halign': 'center',
                  'text-margin-y': 5,
                  'font-size': 10,
                  width: 22,
                  height: 22,
                  'border-width': 2,
                  'border-color': '#1a1a2e',
                  'text-outline-width': 1,
                  'text-outline-color': '#1a1a2e',
                  // Icon inside node using background
                  'background-image': (ele) => {
                    const icon = ele.data('icon') || 'â€¢';
                    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22"><text x="50%" y="55%" text-anchor="middle" dominant-baseline="middle" fill="white" font-family="Arial, sans-serif" font-size="12" font-weight="bold">${icon}</text></svg>`;
                    return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
                  },
                  'background-fit': 'contain',
                  'background-clip': 'none',
                },
              },
              // Module nodes (compound parent nodes)
              {
                selector: 'node[type = "module"]',
                style: {
                  shape: 'round-rectangle',
                  'background-color': '#16213e',
                  'background-opacity': 0.9,
                  'border-width': 1,
                  'border-color': NODE_COLORS.module,
                  'border-opacity': 0.8,
                  label: 'data(label)',
                  color: '#aaa',
                  'text-valign': 'top',
                  'text-halign': 'center',
                  'text-margin-y': -5,
                  'font-size': 9,
                  'text-outline-width': 0,
                  // Minimize compound node area - very small padding
                  padding: 5,
                  'compound-sizing-wrt-labels': 'exclude',
                  // Remove min-width/min-height to allow tight fitting
                  'min-width': 0,
                  'min-height': 0,
                  // Center icon - scales with container, maintains aspect ratio
                  'background-image': `data:image/svg+xml;utf8,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><text x="50%" y="55%" text-anchor="middle" dominant-baseline="middle" fill="#3498db" font-family="Arial, sans-serif" font-size="60" font-weight="bold" opacity="0.3">M</text></svg>')}`,
                  'background-fit': 'contain',
                  'background-width-relative-to': 'inner',
                  'background-height-relative-to': 'inner',
                },
              },
              // Collapsed module (no visible children)
              {
                selector: 'node[type = "module"].collapsed',
                style: {
                  'background-color': NODE_COLORS.module,
                  'background-opacity': 1,
                  padding: 5,
                  'min-width': 30,
                  'min-height': 30,
                  color: '#fff',
                  'text-valign': 'bottom',
                  'text-margin-y': 5,
                },
              },
              // Class nodes (compound parent nodes for methods/fields)
              {
                selector: 'node[type = "class"]',
                style: {
                  shape: 'round-rectangle',
                  'background-color': '#1a1a2e',
                  'background-opacity': 0.85,
                  'border-width': 1,
                  'border-color': NODE_COLORS.class,
                  'border-opacity': 0.8,
                  label: 'data(label)',
                  color: NODE_COLORS.class,
                  'text-valign': 'top',
                  'text-halign': 'center',
                  'text-margin-y': -3,
                  'font-size': 10,
                  'text-outline-width': 0,
                  padding: 8,
                  'compound-sizing-wrt-labels': 'exclude',
                  'min-width': 0,
                  'min-height': 0,
                  // Center icon - scales with container, maintains aspect ratio
                  'background-image': `data:image/svg+xml;utf8,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><text x="50%" y="55%" text-anchor="middle" dominant-baseline="middle" fill="#9b59b6" font-family="Arial, sans-serif" font-size="60" font-weight="bold" opacity="0.3">C</text></svg>')}`,
                  'background-fit': 'contain',
                  'background-width-relative-to': 'inner',
                  'background-height-relative-to': 'inner',
                },
              },
              {
                selector: 'node:selected',
                style: {
                  'border-width': 3,
                  'border-color': '#22d3ee',
                },
              },
              {
                selector: 'edge',
                style: {
                  width: 1,
                  'line-color': (ele) =>
                    EDGE_COLORS[ele.data('type')] || '#666',
                  'target-arrow-color': (ele) =>
                    EDGE_COLORS[ele.data('type')] || '#666',
                  'target-arrow-shape': 'triangle',
                  'curve-style': 'bezier',
                  opacity: 0.6,
                },
              },
              {
                selector: 'edge:selected',
                style: {
                  width: 2,
                  opacity: 1,
                },
              },
              {
                selector: '.hidden',
                style: {
                  display: 'none',
                },
              },
              {
                selector: '.highlighted',
                style: {
                  'border-width': 4,
                  'border-color': '#22d3ee',
                  'border-style': 'double',
                },
              },
            ],
            layout: layoutOptions,
            wheelSensitivity: 0.3,
          });
        } catch (e) {
          console.warn(
            '[chizuts] Dagre layout failed, falling back to cose:',
            e.message
          );
          layoutName = 'cose';
          layoutOptions = { name: 'cose', animate: false };
          cy = cytoscape({
            container: document.getElementById('cy'),
            elements,
            style: [
              // Child nodes (non-module symbols) - fallback
              {
                selector: 'node[type != "module"]',
                style: {
                  label: 'data(label)',
                  'background-color': (ele) =>
                    NODE_COLORS[ele.data('type')] || '#888',
                  color: '#fff',
                  'text-valign': 'bottom',
                  'text-halign': 'center',
                  'font-size': 10,
                  width: 22,
                  height: 22,
                },
              },
              // Module nodes (compound parent nodes) - fallback
              {
                selector: 'node[type = "module"]',
                style: {
                  shape: 'round-rectangle',
                  'background-color': '#16213e',
                  'background-opacity': 0.9,
                  'border-width': 1,
                  'border-color': NODE_COLORS.module,
                  label: 'data(label)',
                  color: '#aaa',
                  'text-valign': 'top',
                  'text-halign': 'center',
                  'font-size': 9,
                  padding: 8,
                  'background-image': `data:image/svg+xml;utf8,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><text x="50%" y="55%" text-anchor="middle" dominant-baseline="middle" fill="#3498db" font-family="Arial, sans-serif" font-size="60" font-weight="bold" opacity="0.3">M</text></svg>')}`,
                  'background-fit': 'contain',
                  'background-width-relative-to': 'inner',
                  'background-height-relative-to': 'inner',
                },
              },
              {
                selector: 'node[type = "module"].collapsed',
                style: {
                  'background-color': NODE_COLORS.module,
                  'background-opacity': 1,
                  padding: 5,
                  color: '#fff',
                  'text-valign': 'bottom',
                },
              },
              // Class nodes (compound parent nodes) - fallback
              {
                selector: 'node[type = "class"]',
                style: {
                  shape: 'round-rectangle',
                  'background-color': '#1a1a2e',
                  'background-opacity': 0.85,
                  'border-width': 1,
                  'border-color': NODE_COLORS.class,
                  label: 'data(label)',
                  color: NODE_COLORS.class,
                  'text-valign': 'top',
                  'text-halign': 'center',
                  'font-size': 10,
                  padding: 8,
                  'background-image': `data:image/svg+xml;utf8,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><text x="50%" y="55%" text-anchor="middle" dominant-baseline="middle" fill="#9b59b6" font-family="Arial, sans-serif" font-size="60" font-weight="bold" opacity="0.3">C</text></svg>')}`,
                  'background-fit': 'contain',
                  'background-width-relative-to': 'inner',
                  'background-height-relative-to': 'inner',
                },
              },
              {
                selector: 'edge',
                style: {
                  width: 1,
                  'line-color': (ele) =>
                    EDGE_COLORS[ele.data('type')] || '#666',
                  'target-arrow-color': (ele) =>
                    EDGE_COLORS[ele.data('type')] || '#666',
                  'target-arrow-shape': 'triangle',
                  'curve-style': 'bezier',
                  opacity: 0.6,
                },
              },
              { selector: '.hidden', style: { display: 'none' } },
            ],
            layout: layoutOptions,
            wheelSensitivity: 0.3,
          });
        }

        // Node click handler - also expand tree to show selected node
        cy.on('tap', 'node', (evt) => {
          const node = evt.target;
          focusNode(node.id(), true);
        });

        // Double-click on module to toggle expand/collapse
        cy.on('dbltap', 'node[type = "module"]', (evt) => {
          const moduleNode = evt.target;
          const isCollapsed = moduleNode.hasClass('collapsed');

          if (isCollapsed) {
            // Expand: show children
            moduleNode.removeClass('collapsed');
            moduleNode.children().forEach((child) => {
              child.removeClass('hidden');
              // Also show edges connected to this child
              getConnectedEdges(child).forEach((edge) => {
                const sourceNode = cy.getElementById(edge.data('source'));
                const targetNode = cy.getElementById(edge.data('target'));
                // Only show edge if both ends are visible
                if (
                  !sourceNode.hasClass('hidden') &&
                  !targetNode.hasClass('hidden')
                ) {
                  edge.removeClass('hidden');
                }
              });
            });
          } else {
            // Collapse: hide children
            moduleNode.addClass('collapsed');
            moduleNode.children().forEach((child) => {
              child.addClass('hidden');
              // Hide edges connected to this child
              getConnectedEdges(child).addClass('hidden');
            });
          }

          // Update stats after collapse/expand
          updateVisibleStats();
        });

        // Helper to update visible node/edge counts
        function updateVisibleStats() {
          const visibleNodes = cy.nodes().filter((n) => !n.hasClass('hidden'));
          const visibleEdges = cy.edges().filter((e) => !e.hasClass('hidden'));
          document.getElementById('filter-stats').textContent =
            `Showing ${visibleNodes.length} symbols, ${visibleEdges.length} relations`;
        }

        // Setup controls, search, and pattern filter
        setupControls();
        setupSearch();

        // Fetch filter config and setup pattern filter
        try {
          const configResponse = await fetch('/api/config');
          const config = await configResponse.json();
          console.log('[chizuts] Fetched config:', config);
          setupPatternFilter(config);
        } catch (err) {
          console.error('[chizuts] Failed to fetch config:', err);
          setupPatternFilter({});
        }

        // Setup sidebar toggles and orphan filter
        setupSidebarToggles();
        setupOrphanFilter();

        // If we have saved positions but there are new nodes, position them near related nodes
        if (hasSavedPositions && nodesWithoutSavedPositions.length > 0) {
          console.log(
            '[chizuts] Positioning',
            nodesWithoutSavedPositions.length,
            'new nodes'
          );

          // For each new node, find a good initial position
          nodesWithoutSavedPositions.forEach((nodeId) => {
            const node = cy.getElementById(nodeId);
            if (node.length === 0) return;

            // Try to position near connected nodes that have positions
            const connectedNodes = node.neighborhood('node').filter((n) => {
              const pos = n.position();
              return pos.x !== 0 || pos.y !== 0;
            });

            if (connectedNodes.length > 0) {
              // Position near the centroid of connected nodes with some offset
              let sumX = 0,
                sumY = 0;
              connectedNodes.forEach((n) => {
                const pos = n.position();
                sumX += pos.x;
                sumY += pos.y;
              });
              const avgX = sumX / connectedNodes.length;
              const avgY = sumY / connectedNodes.length;

              // Add random offset to avoid overlap
              const offsetX = (Math.random() - 0.5) * 100;
              const offsetY = (Math.random() - 0.5) * 100;

              node.position({ x: avgX + offsetX, y: avgY + offsetY });
            } else {
              // No connected nodes with positions, place at a random position in the viewport
              const extent = cy.extent();
              const randomX =
                extent.x1 + Math.random() * (extent.x2 - extent.x1);
              const randomY =
                extent.y1 + Math.random() * (extent.y2 - extent.y1);
              node.position({ x: randomX, y: randomY });
            }
          });

          // Run a short cola layout on just the new nodes to avoid overlaps
          const newNodes = cy
            .nodes()
            .filter((n) => nodesWithoutSavedPositions.includes(n.id()));
          if (newNodes.length > 0) {
            // Lock existing nodes and run layout
            cy.nodes().forEach((n) => {
              if (!nodesWithoutSavedPositions.includes(n.id())) {
                n.lock();
              }
            });

            cy.layout({
              name: 'cola',
              animate: false,
              fit: false,
              avoidOverlap: true,
              nodeSpacing: 10,
              maxSimulationTime: 1000,
            }).run();

            // Unlock all nodes
            cy.nodes().unlock();
          }
        }

        // Fit to screen after initial layout
        cy.fit(50);
      }

      function showNodeInfo(data) {
        const info = document.getElementById('node-info');
        const metadata = data.metadata || {};

        // Build TSDoc section
        let tsdocHtml = '';
        if (metadata.tsdoc) {
          tsdocHtml = `
            <div style="margin-top: 15px; padding: 10px; background: #0f3460; border-radius: 4px;">
              <div style="font-size: 11px; color: #888; margin-bottom: 5px; text-transform: uppercase;">Documentation</div>
              <div style="font-size: 12px; color: #ccc; white-space: pre-wrap; line-height: 1.5;">${escapeHtml(metadata.tsdoc)}</div>
            </div>
          `;
        }

        // Build methods section
        let methodsHtml = '';
        if (metadata.methods && metadata.methods.length > 0) {
          const methodsList = metadata.methods
            .map((m) => {
              const methodDoc = m.tsdoc
                ? `<div style="font-size: 11px; color: #888; margin-top: 3px; margin-left: 20px;">${escapeHtml(m.tsdoc.split('\n')[0])}</div>`
                : '';
              return `<div style="margin: 6px 0;"><span style="color: #2ecc71; font-family: monospace;">Æ’</span> <span style="color: #eee;">${escapeHtml(m.name)}</span>${methodDoc}</div>`;
            })
            .join('');

          methodsHtml = `
            <div style="margin-top: 15px; padding: 10px; background: #0f3460; border-radius: 4px;">
              <div style="font-size: 11px; color: #888; margin-bottom: 8px; text-transform: uppercase;">Public Methods</div>
              ${methodsList}
            </div>
          `;
        }

        // Use NODE_COLORS directly to ensure badge color matches node color
        const badgeColor = NODE_COLORS[data.type] || '#888';

        info.innerHTML = `
          <div class="label">${escapeHtml(data.label)}</div>
          <div class="type" style="background: ${badgeColor};">${data.type}</div>
          <div class="path">${escapeHtml(data.filePath)}</div>
          <div class="location">Line ${data.line}, Column ${data.column}</div>
          ${tsdocHtml}
          ${methodsHtml}
        `;
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      function setupControls() {
        // Restore layout selection from localStorage
        const savedLayout = loadState(STORAGE_KEYS.selectedLayout);
        const layoutSelect = document.getElementById('layout');
        if (savedLayout && layoutSelect) {
          layoutSelect.value = savedLayout;
        }

        // Layout selector
        layoutSelect.addEventListener('change', (e) => {
          const layoutValue = e.target.value;
          saveState(STORAGE_KEYS.selectedLayout, layoutValue);
          const layoutOptions = {
            animate: true,
            animationDuration: 500,
          };

          // Configure layout based on selection
          if (layoutValue === 'cola') {
            layoutOptions.name = 'cola';
            layoutOptions.avoidOverlap = true;
            layoutOptions.edgeLength = (edge) => 60;
            layoutOptions.nodeSpacing = 10;
            layoutOptions.flow = { axis: 'y', minSeparation: 30 };
            layoutOptions.convergenceThreshold = 0.01;
            layoutOptions.handleDisconnected = true;
            layoutOptions.randomize = true;
            layoutOptions.maxSimulationTime = 4000;
            layoutOptions.unconstrIter = 10;
            layoutOptions.userConstIter = 20;
            layoutOptions.allConstIter = 20;
          } else if (layoutValue === 'fcose') {
            layoutOptions.name = 'fcose';
            layoutOptions.nodeDimensionsIncludeLabels = true;
            layoutOptions.uniformNodeDimensions = false;
            layoutOptions.packComponents = true;
            layoutOptions.quality = 'proof';
            layoutOptions.randomize = true;
            layoutOptions.numIter = 2500;
            layoutOptions.idealEdgeLength = (edge) => 50;
            layoutOptions.edgeElasticity = (edge) => 0.45;
            layoutOptions.nodeSeparation = 100;
            layoutOptions.tile = true;
            layoutOptions.tilingPaddingVertical = 20;
            layoutOptions.tilingPaddingHorizontal = 20;
            layoutOptions.gravity = 0.25;
            layoutOptions.gravityRange = 3.8;
            layoutOptions.gravityCompound = 1.0;
            layoutOptions.gravityRangeCompound = 1.5;
            layoutOptions.nodeRepulsion = (node) =>
              node.isParent() ? 8000 : 4500;
            layoutOptions.nestingFactor = 0.1;
            layoutOptions.initialEnergyOnIncremental = 0.3;
          } else if (layoutValue === 'dagre') {
            layoutOptions.name = 'dagre';
            layoutOptions.rankDir = 'TB';
            layoutOptions.nodeSep = 30;
            layoutOptions.rankSep = 100;
            layoutOptions.edgeSep = 10;
          } else if (layoutValue === 'dagre-lr') {
            layoutOptions.name = 'dagre';
            layoutOptions.rankDir = 'LR';
            layoutOptions.nodeSep = 30;
            layoutOptions.rankSep = 100;
            layoutOptions.edgeSep = 10;
          } else if (layoutValue === 'dagre-compact') {
            layoutOptions.name = 'dagre';
            layoutOptions.rankDir = 'TB';
            layoutOptions.nodeSep = 15;
            layoutOptions.rankSep = 50;
            layoutOptions.edgeSep = 5;
          } else if (layoutValue === 'concentric') {
            layoutOptions.name = 'concentric';
            layoutOptions.concentric = (node) => node.degree();
            layoutOptions.levelWidth = () => 2;
            layoutOptions.minNodeSpacing = 50;
          } else if (layoutValue === 'cose') {
            layoutOptions.name = 'cose';
            layoutOptions.nodeRepulsion = 8000;
            layoutOptions.idealEdgeLength = 100;
            layoutOptions.edgeElasticity = 100;
          } else {
            layoutOptions.name = layoutValue;
          }

          cy.layout(layoutOptions).run();
        });

        // Fit button
        document.getElementById('fit-btn').addEventListener('click', () => {
          cy.fit();
        });

        // Export button
        document.getElementById('export-btn').addEventListener('click', () => {
          const png = cy.png({ full: true, scale: 2 });
          const link = document.createElement('a');
          link.download = 'dependency-graph.png';
          link.href = png;
          link.click();
        });

        // Save Layout button
        document
          .getElementById('save-layout-btn')
          .addEventListener('click', () => {
            saveLayout();
          });

        // Restore hidden node types from localStorage
        const savedHiddenNodeTypes = loadState(
          STORAGE_KEYS.hiddenNodeTypes,
          []
        );
        savedHiddenNodeTypes.forEach((type) => {
          const legendItem = document.querySelector(
            `#legend .legend-item[data-type="${type}"]`
          );
          if (legendItem) {
            legendItem.classList.add('inactive');
            cy.nodes().forEach((node) => {
              if (node.data('type') === type) {
                node.addClass('hidden');
              }
            });
          }
        });

        // Type filters via clickable legend items (nodes)
        document
          .querySelectorAll('#legend .legend-item.clickable')
          .forEach((item) => {
            item.addEventListener('click', () => {
              const type = item.dataset.type;
              const isActive = !item.classList.contains('inactive');

              // Toggle active state
              item.classList.toggle('inactive');

              cy.nodes().forEach((node) => {
                if (node.data('type') === type) {
                  if (isActive) {
                    node.addClass('hidden');
                  } else {
                    node.removeClass('hidden');
                  }
                }
              });

              // Save hidden node types to localStorage
              const hiddenTypes = [];
              document
                .querySelectorAll('#legend .legend-item.clickable.inactive')
                .forEach((el) => {
                  hiddenTypes.push(el.dataset.type);
                });
              saveState(STORAGE_KEYS.hiddenNodeTypes, hiddenTypes);

              // Update orphan filter if active
              updateOrphanVisibility();
            });
          });

        // Restore hidden edge types from localStorage
        const savedHiddenEdgeTypes = loadState(
          STORAGE_KEYS.hiddenEdgeTypes,
          []
        );
        savedHiddenEdgeTypes.forEach((edgeType) => {
          const legendItem = document.querySelector(
            `#edge-legend .legend-item[data-edge-type="${edgeType}"]`
          );
          if (legendItem) {
            legendItem.classList.add('inactive');
            cy.edges().forEach((edge) => {
              if (edge.data('type') === edgeType) {
                edge.addClass('hidden');
              }
            });
          }
        });

        // Edge type filters via clickable legend items
        document
          .querySelectorAll('#edge-legend .legend-item.clickable')
          .forEach((item) => {
            item.addEventListener('click', () => {
              const edgeType = item.dataset.edgeType;
              const isActive = !item.classList.contains('inactive');

              // Toggle active state
              item.classList.toggle('inactive');

              cy.edges().forEach((edge) => {
                if (edge.data('type') === edgeType) {
                  if (isActive) {
                    edge.addClass('hidden');
                  } else {
                    edge.removeClass('hidden');
                  }
                }
              });

              // Save hidden edge types to localStorage
              const hiddenEdgeTypes = [];
              document
                .querySelectorAll(
                  '#edge-legend .legend-item.clickable.inactive'
                )
                .forEach((el) => {
                  hiddenEdgeTypes.push(el.dataset.edgeType);
                });
              saveState(STORAGE_KEYS.hiddenEdgeTypes, hiddenEdgeTypes);

              // Update orphan filter based on visible edges
              updateOrphanVisibility();
            });
          });
      }

      // Helper function to get connected edges for a node
      // Note: cy.connectedEdges() doesn't work correctly for compound node children,
      // so we manually filter edges by source/target ID
      function getConnectedEdges(node) {
        const nodeId = node.id();
        return cy.edges().filter(
          (e) => e.data('source') === nodeId || e.data('target') === nodeId
        );
      }

      // Helper to check if a node should be hidden by pattern filter
      function isNodeHiddenByPatternFilter(node) {
        const excludeInput = document.getElementById('exclude-patterns');
        const includeInput = document.getElementById('include-patterns');
        if (!excludeInput || !includeInput) return false;

        const excludePatterns = excludeInput.value
          .split('\n')
          .map((p) => p.trim())
          .filter((p) => p.length > 0);
        const includePatterns = includeInput.value
          .split('\n')
          .map((p) => p.trim())
          .filter((p) => p.length > 0);

        if (excludePatterns.length === 0 && includePatterns.length === 0) {
          return false;
        }

        const filePath = node.data('filePath') || node.data('label') || '';
        const label = node.data('label') || '';
        const pathToCheck = filePath || label;

        // If include patterns exist, only show matching nodes
        if (includePatterns.length > 0) {
          if (!matchesPatterns(pathToCheck, includePatterns)) {
            return true;
          }
        }

        // If exclude patterns exist, hide matching nodes
        if (excludePatterns.length > 0) {
          if (matchesPatterns(pathToCheck, excludePatterns)) {
            return true;
          }
        }

        return false;
      }

      // Helper to check if a node is orphan (no edges and no visible children)
      function isNodeOrphan(node) {
        // Compound nodes (modules/classes with children) are not orphans
        const visibleChildren = node
          .children()
          .filter((c) => !c.hasClass('hidden'));
        if (visibleChildren.length > 0) {
          return false;
        }

        // Check for visible connected edges
        // An edge is visible if:
        // 1. The edge itself is not hidden
        // 2. Both source and target nodes are not hidden
        const visibleEdges = getConnectedEdges(node).filter((e) => {
          if (e.hasClass('hidden')) return false;
          const sourceNode = cy.getElementById(e.data('source'));
          const targetNode = cy.getElementById(e.data('target'));
          return !sourceNode.hasClass('hidden') && !targetNode.hasClass('hidden');
        });
        return visibleEdges.length === 0;
      }

      function updateOrphanVisibility() {
        const hideOrphansCheckbox = document.getElementById('hide-orphans');
        if (!hideOrphansCheckbox || !hideOrphansCheckbox.checked) return;

        // Re-apply orphan hiding based on currently visible edges
        cy.nodes().forEach((node) => {
          // Check if node type is hidden
          const nodeType = node.data('type');
          const nodeTypeHidden = document
            .querySelector(`#legend .legend-item[data-type="${nodeType}"]`)
            ?.classList.contains('inactive');

          if (nodeTypeHidden) {
            node.addClass('hidden');
            return;
          }

          // Check if node is hidden by pattern filter
          if (isNodeHiddenByPatternFilter(node)) {
            node.addClass('hidden');
            return;
          }

          const isOrphan = isNodeOrphan(node);

          if (isOrphan) {
            node.addClass('hidden');
          } else {
            node.removeClass('hidden');
          }
        });

        // Update stats
        const orphanStats = document.getElementById('orphan-stats');
        if (orphanStats) {
          const total = cy.nodes().length;
          const orphans = cy.nodes().filter((n) => isNodeOrphan(n)).length;
          orphanStats.textContent = `${orphans} orphan symbols out of ${total} total`;
        }
      }

      function setupPatternFilter(config = {}) {
        console.log('[chizuts] setupPatternFilter called with config:', config);

        const applyBtn = document.getElementById('apply-pattern-filter');
        const excludeInput = document.getElementById('exclude-patterns');
        const includeInput = document.getElementById('include-patterns');
        const filterStats = document.getElementById('filter-stats');

        if (!excludeInput || !includeInput || !applyBtn || !filterStats) {
          console.error('[chizuts] Filter elements not found!', {
            applyBtn: !!applyBtn,
            excludeInput: !!excludeInput,
            includeInput: !!includeInput,
            filterStats: !!filterStats,
          });
          return;
        }

        // First restore from localStorage (user's saved preferences take priority)
        const savedExcludePatterns = loadState(
          STORAGE_KEYS.excludePatterns,
          null
        );
        const savedIncludePatterns = loadState(
          STORAGE_KEYS.includePatterns,
          null
        );

        // Use saved patterns if available, otherwise use CLI config
        if (savedExcludePatterns !== null) {
          excludeInput.value = savedExcludePatterns;
          console.log('[chizuts] Restored exclude patterns from localStorage');
        } else if (config.exclude && config.exclude.length > 0) {
          excludeInput.value = config.exclude.join('\n');
          console.log(
            '[chizuts] Set exclude patterns from CLI:',
            config.exclude
          );
        }

        if (savedIncludePatterns !== null) {
          includeInput.value = savedIncludePatterns;
          console.log('[chizuts] Restored include patterns from localStorage');
        } else if (config.include && config.include.length > 0) {
          includeInput.value = config.include.join('\n');
          console.log(
            '[chizuts] Set include patterns from CLI:',
            config.include
          );
        }

        const applyFilter = () => {
          console.log('[chizuts] applyFilter called');
          console.log(
            '[chizuts] excludeInput.value:',
            JSON.stringify(excludeInput.value)
          );
          console.log(
            '[chizuts] includeInput.value:',
            JSON.stringify(includeInput.value)
          );

          // Save patterns to localStorage
          saveState(STORAGE_KEYS.excludePatterns, excludeInput.value);
          saveState(STORAGE_KEYS.includePatterns, includeInput.value);

          // Parse patterns from textareas
          const excludePatterns = excludeInput.value
            .split('\n')
            .map((p) => p.trim())
            .filter((p) => p.length > 0);
          const includePatterns = includeInput.value
            .split('\n')
            .map((p) => p.trim())
            .filter((p) => p.length > 0);

          console.log('[chizuts] excludePatterns:', excludePatterns);
          console.log('[chizuts] includePatterns:', includePatterns);
          console.log('[chizuts] cy.nodes() count:', cy.nodes().length);

          let hiddenCount = 0;
          let shownCount = 0;

          cy.nodes().forEach((node) => {
            const filePath = node.data('filePath') || node.data('label') || '';
            const label = node.data('label') || '';

            // Check path against patterns (check both filePath and label)
            const pathToCheck = filePath || label;

            let shouldHide = false;

            // If include patterns exist, only show matching nodes
            if (includePatterns.length > 0) {
              if (!matchesPatterns(pathToCheck, includePatterns)) {
                shouldHide = true;
              }
            }

            // If exclude patterns exist and node wasn't already hidden, check exclusion
            if (!shouldHide && excludePatterns.length > 0) {
              if (matchesPatterns(pathToCheck, excludePatterns)) {
                shouldHide = true;
              }
            }

            if (shouldHide) {
              node.addClass('hidden');
              hiddenCount++;
            } else {
              node.removeClass('hidden');
              shownCount++;
            }
          });

          // Update filter stats
          if (excludePatterns.length > 0 || includePatterns.length > 0) {
            filterStats.textContent = `Showing ${shownCount} symbols, ${hiddenCount} hidden`;
          } else {
            filterStats.textContent = 'All symbols visible';
          }
          console.log('[chizuts] Filter applied:', { shownCount, hiddenCount });
        };

        applyBtn.addEventListener('click', applyFilter);

        // Auto-apply if patterns are provided (either from localStorage or CLI config)
        const hasPatterns =
          excludeInput.value.trim().length > 0 ||
          includeInput.value.trim().length > 0;
        if (hasPatterns) {
          console.log('[chizuts] Auto-applying filter from saved/CLI config');
          applyFilter();
        }
      }

      // Setup sidebar toggle buttons
      function setupSidebarToggles() {
        const leftClose = document.getElementById('left-close');
        const leftExpand = document.getElementById('left-expand');
        const rightClose = document.getElementById('right-close');
        const rightExpand = document.getElementById('right-expand');
        const leftSidebar = document.getElementById('left-sidebar');
        const sidebar = document.getElementById('sidebar');

        // Left sidebar close button
        leftClose.addEventListener('click', () => {
          leftSidebar.classList.add('collapsed');
          document.body.classList.add('left-collapsed');
          setTimeout(() => cy.resize(), 350);
        });

        // Left sidebar expand tab
        leftExpand.addEventListener('click', () => {
          leftSidebar.classList.remove('collapsed');
          document.body.classList.remove('left-collapsed');
          setTimeout(() => cy.resize(), 350);
        });

        // Right sidebar close button
        rightClose.addEventListener('click', () => {
          sidebar.classList.add('collapsed');
          document.body.classList.add('right-collapsed');
          setTimeout(() => cy.resize(), 350);
        });

        // Right sidebar expand tab
        rightExpand.addEventListener('click', () => {
          sidebar.classList.remove('collapsed');
          document.body.classList.remove('right-collapsed');
          setTimeout(() => cy.resize(), 350);
        });
      }

      // Setup orphan node filter
      function setupOrphanFilter() {
        const hideOrphansCheckbox = document.getElementById('hide-orphans');
        const orphanStats = document.getElementById('orphan-stats');

        // Count orphan nodes using the shared isNodeOrphan helper
        const countOrphans = () => {
          return cy.nodes().filter((node) => isNodeOrphan(node)).length;
        };

        const updateOrphanStats = () => {
          const total = cy.nodes().length;
          const orphans = countOrphans();
          orphanStats.textContent = `${orphans} orphan symbols out of ${total} total`;
        };

        // Restore hide orphans checkbox state from localStorage
        const savedHideOrphans = loadState(STORAGE_KEYS.hideOrphans, false);
        hideOrphansCheckbox.checked = savedHideOrphans;

        // Apply saved hide orphans state
        if (savedHideOrphans) {
          cy.nodes().forEach((node) => {
            if (isNodeOrphan(node)) {
              node.addClass('hidden');
            }
          });
        }

        updateOrphanStats();

        hideOrphansCheckbox.addEventListener('change', () => {
          const hideOrphans = hideOrphansCheckbox.checked;
          // Save hide orphans state to localStorage
          saveState(STORAGE_KEYS.hideOrphans, hideOrphans);

          cy.nodes().forEach((node) => {
            // Check if node type is hidden
            const nodeType = node.data('type');
            const nodeTypeHidden = document
              .querySelector(`#legend .legend-item[data-type="${nodeType}"]`)
              ?.classList.contains('inactive');

            if (nodeTypeHidden) {
              // Keep hidden if type is hidden
              return;
            }

            // Check if node is hidden by pattern filter
            if (isNodeHiddenByPatternFilter(node)) {
              // Keep hidden if pattern filter hides it
              return;
            }

            const isOrphan = isNodeOrphan(node);

            if (isOrphan) {
              if (hideOrphans) {
                node.addClass('hidden');
              } else {
                node.removeClass('hidden');
              }
            }
          });

          updateOrphanStats();
        });
      }

      // Connect to SSE for watch mode updates
      function setupWatchMode() {
        const eventSource = new EventSource('/api/events');

        eventSource.addEventListener('connected', () => {
          console.log('Watch mode connected');
        });

        eventSource.addEventListener('update', () => {
          console.log('Graph updated, reloading...');
          // Re-fetch and update the graph
          fetch('/api/graph')
            .then((res) => res.json())
            .then((graph) => {
              // Update stats
              document.getElementById('stats').textContent =
                `${graph.nodes.length} symbols, ${graph.edges.length} relations, ${graph.metadata.fileCount} files`;

              // Rebuild elements with parent assignment for compound nodes
              const elements = [];

              // Build module ID lookup for parent assignment
              const moduleIds = new Set(
                graph.nodes.filter((n) => n.type === 'module').map((n) => n.id)
              );

              // Build class ID lookup for parent assignment
              const classIds = new Set(
                graph.nodes.filter((n) => n.type === 'class').map((n) => n.id)
              );

              // Helper to find parent ID from a node ID
              function getParentId(nodeId) {
                if (!nodeId.includes('#')) return null;
                const symbolPart = nodeId.split('#')[1];

                // Check if this is a class member (contains '.')
                if (symbolPart && symbolPart.includes('.')) {
                  const className = symbolPart.split('.')[0];
                  const moduleId = nodeId.split('#')[0];
                  const classId = `${moduleId}#${className}`;
                  if (classIds.has(classId)) {
                    return classId;
                  }
                }

                const moduleId = nodeId.split('#')[0];
                return moduleIds.has(moduleId) ? moduleId : null;
              }

              // Sort so container nodes are added before their children
              const sortedNodes = [...graph.nodes].sort((a, b) => {
                const order = { module: 0, class: 1 };
                const aOrder = order[a.type] ?? 2;
                const bOrder = order[b.type] ?? 2;
                return aOrder - bOrder;
              });

              for (const node of sortedNodes) {
                const parentId = getParentId(node.id);
                elements.push({
                  data: {
                    id: node.id,
                    label: node.label,
                    type: node.type,
                    icon: SYMBOL_ICONS[node.type] || 'â€¢',
                    filePath: node.filePath,
                    line: node.line,
                    column: node.column,
                    metadata: node.metadata,
                    parent: parentId,
                  },
                });
              }

              for (const edge of graph.edges) {
                // Skip edges from container to its children (redundant with compound nodes)
                // 1. Module -> direct children
                if (
                  moduleIds.has(edge.source) &&
                  edge.target.startsWith(edge.source + '#') &&
                  !edge.target.slice(edge.source.length + 1).includes('.')
                ) {
                  continue;
                }
                // 2. Class -> methods/fields
                if (
                  classIds.has(edge.source) &&
                  edge.target.startsWith(edge.source + '.')
                ) {
                  continue;
                }

                const sourceExists = graph.nodes.some(
                  (n) => n.id === edge.source
                );
                const targetExists = graph.nodes.some(
                  (n) => n.id === edge.target
                );

                if (sourceExists && targetExists) {
                  elements.push({
                    data: {
                      id: `${edge.source}->${edge.target}`,
                      source: edge.source,
                      target: edge.target,
                      type: edge.type,
                    },
                  });
                }
              }

              // Update cytoscape
              cy.elements().remove();
              cy.add(elements);
              cy.layout({
                name: document.getElementById('layout').value,
                animate: false,
              }).run();
            })
            .catch(console.error);
        });

        eventSource.onerror = () => {
          console.log('Watch mode disconnected, will retry...');
        };
      }

      init()
        .then(() => {
          // Try to connect to watch mode (will fail gracefully if not enabled)
          setupWatchMode();
        })
        .catch(console.error);
    </script>
  </body>
</html>
